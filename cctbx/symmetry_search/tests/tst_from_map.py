from cctbx.development import debug_utils, random_structurefrom cctbx import millerfrom cctbx import symmetry_searchfrom cctbx import sgtbxfrom cctbx.array_family import flexfrom scitbx import matrix as matfrom libtbx.test_utils import approx_equalimport scitbx.randomimport sysimport mathdef exercise_one(flags, space_group_info,             elements, anomalous_flag, d_min,             grid_resolution_factor):  target_space_group_type = space_group_info.type()  print target_space_group_type.hall_symbol()  # Generate a random structure in real space,  # compute its structure factors,  # that we will try to recover the symmetry of  target_structure = random_structure.xray_structure(    space_group_info=space_group_info,    elements=elements,    use_u_iso=True,    random_u_iso=True,    random_u_iso_scale=0.04,    use_u_aniso=False,  )  if flags.non_random_shift:    shifted_origin = mat.col((0.1, 0.2, 0.3))  else:    shifted_origin = mat.col(flex.random_double(3))  if flags.Verbose:    print "new origin = (%.3f, %.3f, %.3f)" % shifted_origin.elems    print  target_structure_in_p1 = target_structure\                         .expand_to_p1().apply_shift(-shifted_origin)  target_f_in_p1 = miller.build_set(    crystal_symmetry=target_structure_in_p1,    anomalous_flag=True,    d_min=d_min    ).structure_factors_from_scatterers(      xray_structure=target_structure_in_p1,      algorithm="direct").f_calc()  # Recover centring?  sf_symm = symmetry_search.structure_factor_symmetry(target_f_in_p1)  sf_symm.find_centring_translations()  assert (    sf_symm.space_group.conventional_centring_type_symbol()    == target_structure.space_group().conventional_centring_type_symbol())  # Recover space group?  sf_symm.find_space_group()  if flags.Verbose:    print sf_symm  target_sgi = target_structure.space_group_info()  target_to_reference_cb_op = (    target_sgi    .change_of_basis_op_to_reference_setting())  solution_to_reference_cb_op = (    sf_symm.space_group_info    .change_of_basis_op_to_reference_setting())  solution_to_target_cb_op = (target_to_reference_cb_op.inverse()                              *solution_to_reference_cb_op)  solution_sgi_target_setting = (    sf_symm.space_group_info.change_basis(solution_to_target_cb_op))  solution_origin = mat.col(solution_to_target_cb_op(sf_symm.origin))  assert (solution_sgi_target_setting.type().hall_symbol()          == target_sgi.type().hall_symbol()          ), solution_sgi_target_setting.type().hall_symbol()  delta = solution_origin - shifted_origin  assert target_sgi.is_allowed_origin_shift(    delta, tolerance=0.01), deltadef exercise(flags, space_group_info,             anomalous_flag, d_min,             grid_resolution_factor):  n = len(space_group_info.group())  n_C = 5  n_O = 1  n_N = 1  if flags.Verbose:    print "C%i O%i N%i" % (n_C*n, n_O*n, n_N*n)  exercise_one(flags=flags,               space_group_info=space_group_info,               elements=["C"]*n_C + ["O"]*n_O + ["N"]*n_N,               anomalous_flag=anomalous_flag,               d_min=d_min,               grid_resolution_factor=grid_resolution_factor)  if flags.Verbose: print  return Truedef run():  debug_utils.parse_options_loop_space_groups(    sys.argv[1:],    keywords=('non_random_shift',),    call_back=exercise,    symbols_to_stderr=False,    anomalous_flag=False,    d_min=0.8,    grid_resolution_factor=1/3,  )if __name__ == '__main__':  run()

// $Id$
/* Copyright (c) 2001 The Regents of the University of California through
   E.O. Lawrence Berkeley National Laboratory, subject to approval by the
   U.S. Department of Energy. See files COPYRIGHT.txt and
   cctbx/LICENSE.txt for further details.

   Revision history:
     2002 Jul: Created from fragments of cctbx/sgtbx/miller_asu.h (rwgk)
 */

#ifndef CCTBX_MILLER_BUILD_H
#define CCTBX_MILLER_BUILD_H

#include <cctbx/array_family/loops.h>
#include <cctbx/sgtbx/miller_asu.h>

namespace cctbx { namespace miller {

  /*! \brief Efficient, easy-to-use algorithm for building
      an asymmetric unit of Miller indices up to a given
      high-resolution limit or up to a given maximum Miller
      index.
   */
  /*! Example (Python syntax):<pre>
        # Given a resolution limit.
        UnitCell = uctbx.UnitCell((10, 10, 10, 90, 90, 90))
        SgOps = sgtbx.SpaceGroup("P 41")
        MIG = sgtbx.MillerIndexGenerator(UnitCell, SgOps.Info(), 1, 3.0)
        for H in MIG: print H
        #
        # Given a maximum Miller index.
        SgOps = sgtbx.SpaceGroup("P 31")
        MIG = sgtbx.MillerIndexGenerator(SgOps.Info(), 1, (3,4,5))
        for H in MIG: print H
      </pre>
      This class is implemented as an iterator. Therefore
      the generation of Miller indices does not consume any
      significant amounts of memory. The key to efficiency
      is cctbx::sgtbx::ReferenceReciprocalSpaceASU .
   */
  class IndexGenerator
  {
    public:
      //! Default constructor.
      /*! Default-constructed instances will throw exceptions if
          some of the member functions are used.
       */
      IndexGenerator() {}
      //! Initialization with resolution limit.
      /*! Miller indices up to and including Resolution_d_min will
          be generated.
       */
      IndexGenerator(const uctbx::UnitCell& uc,
                     const sgtbx::SpaceGroupInfo& SgInfo,
                     bool FriedelFlag,
                     double Resolution_d_min);
      //! Initialization with maximum Miller index.
      /*! Miller indices in the range from -MaxIndex to +MaxIndex
          will be generated.
       */
      IndexGenerator(const sgtbx::SpaceGroupInfo& SgInfo,
                     bool FriedelFlag,
                     const Index& MaxIndex);
      //! Access to the reciprocal space asymmetric unit.
      /*! The Miller indices that are generated by this class (member
          function next()) are inside this asymmetric unit.
       */
      const sgtbx::ReciprocalSpaceASU& ASU() const { return m_ASU; }
      //! Iterator over Miller indices.
      /*! Each call to this member function will return the next
          Miller index in the sequence. The indices are inside
          sgtbx::ReciprocalSpaceASU(). Systematically absent reflections
          are automatically filtered out.
          <p>
          The Miller index 0,0,0 indicates the end of the iteration.
       */
      Index next();
      //! Add all Miller indices to an array.
      /*! The next() method is called in a loop until the list
          of Miller indices is exhausted. The results are added
          to ArrayOfH.
          <p>
          Requirements for MillerArrayType:
          <ul>
          <li>Must contain objects of type miller::Index.
          <li>Must support the push_back() method.
          </ul>
          <p>
          Example:<pre>
          cctbx::uctbx::UnitCell UC(...);
          cctbx::sgtbx::SpaceGroupInfo SgInfo(...);
          cctbx::af::shared<Index> ArrayOfH;
          miller::IndexGenerator(UC, SgInfo, true, 1.0).AddtoArray(ArrayOfH);
          </pre>
       */
      template <class MillerArrayType>
      void
      AddToArray(MillerArrayType& ArrayOfH)
      {
        for (;;) {
          Index H = next();
          if (H.is000()) break;
          ArrayOfH.push_back(H);
        }
      }
    private:
      void InitializeLoop(const Index& ReferenceHmax);
      bool set_phase_info(const Index& h);
      Index next_under_friedel_symmetry();
      uctbx::UnitCell m_UnitCell;
      int m_SgNumber;
      sgtbx::SpaceGroup m_SgOps;
      bool m_FriedelFlag;
      sgtbx::ReciprocalSpaceASU m_ASU;
      double m_Qhigh;
      af::nested_loop<Index> m_loop;
      bool m_next_is_minus_previous;
      sgtbx::PhaseInfo m_phase_info;
      Index m_previous;
  };

}} // namespace cctbx::miller

#endif // CCTBX_MILLER_BUILD_H

/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : cifWalker.g
 *     -                            On : 2011-09-14 17:21:58
 *     -           for the tree parser : cifWalkerTreeParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "cifWalker.h"
/* ----------------------------------------- */

/** CIF Version 1.1 Working specification grammar

Translated from the grammar defined at

http://www.iucr.org/resources/cif/spec/version1.1/cifsyntax#bnf

A compiled version of the parser, with C language target, but contains
C++ code in the actions, therefore the output files must be renamed to *.cpp

Richard Gildea
April 2010
*/




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define         CTX     ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef  SCOPE_TYPE
#undef  SCOPE_STACK
#undef  SCOPE_TOP
#define SCOPE_TYPE(scope)   pcifWalker_##scope##_SCOPE
#define SCOPE_STACK(scope)  pcifWalker_##scope##Stack
#define SCOPE_TOP(scope)    ctx->pcifWalker_##scope##Top
#define SCOPE_SIZE(scope)               ctx->pcifWalker_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)        (ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef      PARSER
#undef      RECOGNIZER
#undef      HAVEPARSEDRULE
#undef      INPUT
#undef      STRSTREAM
#undef      HASEXCEPTION
#undef      EXCEPTION
#undef      MATCHT
#undef      MATCHANYT
#undef      FOLLOWSTACK
#undef      FOLLOWPUSH
#undef      FOLLOWPOP
#undef      PRECOVER
#undef      PREPORTERROR
#undef      LA
#undef      LT
#undef      CONSTRUCTEX
#undef      CONSUME
#undef      MARK
#undef      REWIND
#undef      REWINDLAST
#undef      PERRORRECOVERY
#undef      HASFAILED
#undef      FAILEDFLAG
#undef      RECOVERFROMMISMATCHEDSET
#undef      RECOVERFROMMISMATCHEDELEMENT
#undef      BACKTRACKING
#undef      ADAPTOR
#undef      RULEMEMO
#undef          SEEK
#undef          INDEX
#undef          DBG

#define     PARSER                                                      ctx->pTreeParser
#define     RECOGNIZER                                          PARSER->rec
#define         PSRSTATE                                                RECOGNIZER->state
#define     HAVEPARSEDRULE(r)                           RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define     INPUT                                                       PARSER->ctnstream
#define         ISTREAM                                                 INPUT->tnstream->istream
#define     STRSTREAM                                           INPUT->tnstream
#define     HASEXCEPTION()                                      (PSRSTATE->error == ANTLR3_TRUE)
#define     EXCEPTION                                           PSRSTATE->exception
#define     MATCHT(t, fs)                                       RECOGNIZER->match(RECOGNIZER, t, fs)
#define     MATCHANYT()                                         RECOGNIZER->matchAny(RECOGNIZER)
#define     FOLLOWSTACK                                     PSRSTATE->following
#define     FOLLOWPUSH(x)                                       FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define     FOLLOWPOP()                                         FOLLOWSTACK->pop(FOLLOWSTACK)
#define     PRECOVER()                                          RECOGNIZER->recover(RECOGNIZER)
#define     PREPORTERROR()                                      RECOGNIZER->reportError(RECOGNIZER)
#define     LA(n)                                                       ISTREAM->_LA(ISTREAM, n)
#define     LT(n)                                                       INPUT->tnstream->_LT(INPUT->tnstream, n)
#define     CONSTRUCTEX()                                       RECOGNIZER->exConstruct(RECOGNIZER)
#define     CONSUME()                                           ISTREAM->consume(ISTREAM)
#define     MARK()                                                      ISTREAM->mark(ISTREAM)
#define     REWIND(m)                                           ISTREAM->rewind(ISTREAM, m)
#define     REWINDLAST()                                        ISTREAM->rewindLast(ISTREAM)
#define     PERRORRECOVERY                                      PSRSTATE->errorRecovery
#define     FAILEDFLAG                                          PSRSTATE->failed
#define     HASFAILED()                                         (FAILEDFLAG == ANTLR3_TRUE)
#define     BACKTRACKING                                        PSRSTATE->backtracking
#define     RECOVERFROMMISMATCHEDSET(s)         RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define     RECOVERFROMMISMATCHEDELEMENT(e)     RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define         RULEMEMO                                                PSRSTATE->ruleMemo
#define         SEEK(n)                                                 ISTREAM->seek(ISTREAM, n)
#define         INDEX()                                                 ISTREAM->index(ISTREAM)
#define         DBG                                                             RECOGNIZER->debugger



#define         TOKTEXT(tok, txt)                               tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define     UP      ANTLR3_TOKEN_UP
#define     DOWN    ANTLR3_TOKEN_DOWN
#define     EOR     ANTLR3_TOKEN_EOR
#define     INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a cifWalker_parse scope set
 */
static pcifWalker_parse_SCOPE   pcifWalker_parsePush(pcifWalker ctx);
static void ANTLR3_CDECL parseFree(pcifWalker_parse_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL parseFree(pcifWalker_parse_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a cifWalker parse scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pcifWalker_parseTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pcifWalker_parse_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pcifWalker_parse_SCOPE
pcifWalker_parsePush(pcifWalker ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pcifWalker_parse_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pcifWalker_parseStack->size(ctx->pcifWalker_parseStack) > ctx->pcifWalker_parseStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pcifWalker_parse_SCOPE)ctx->pcifWalker_parseStack->get(ctx->pcifWalker_parseStack, ctx->pcifWalker_parseStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pcifWalker_parse_SCOPE) ANTLR3_MALLOC(sizeof(cifWalker_parse_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pcifWalker_parseStack->push(ctx->pcifWalker_parseStack, newAttributes, (void (*)(void *))parseFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pcifWalker_parseStack_limit++;

        /* Return value is the pointer to the new entry, which may be used locally
         * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a cifWalker_data_items scope set
 */
static pcifWalker_data_items_SCOPE   pcifWalker_data_itemsPush(pcifWalker ctx);
static void ANTLR3_CDECL data_itemsFree(pcifWalker_data_items_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL data_itemsFree(pcifWalker_data_items_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a cifWalker data_items scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pcifWalker_data_itemsTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pcifWalker_data_items_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pcifWalker_data_items_SCOPE
pcifWalker_data_itemsPush(pcifWalker ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pcifWalker_data_items_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pcifWalker_data_itemsStack->size(ctx->pcifWalker_data_itemsStack) > ctx->pcifWalker_data_itemsStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pcifWalker_data_items_SCOPE)ctx->pcifWalker_data_itemsStack->get(ctx->pcifWalker_data_itemsStack, ctx->pcifWalker_data_itemsStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pcifWalker_data_items_SCOPE) ANTLR3_MALLOC(sizeof(cifWalker_data_items_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pcifWalker_data_itemsStack->push(ctx->pcifWalker_data_itemsStack, newAttributes, (void (*)(void *))data_itemsFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pcifWalker_data_itemsStack_limit++;

        /* Return value is the pointer to the new entry, which may be used locally
         * without de-referencing via the context.
     */
    return  newAttributes;
}







/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   cifWalkerTokenNames[40+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ANY_PRINT_CHAR",
        (pANTLR3_UINT8) "CHAR_STRING",
        (pANTLR3_UINT8) "CIF",
        (pANTLR3_UINT8) "COMMENTS",
        (pANTLR3_UINT8) "DATA_",
        (pANTLR3_UINT8) "DATA_BLOCK",
        (pANTLR3_UINT8) "DATA_BLOCK_HEADING",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "DOUBLE_QUOTE",
        (pANTLR3_UINT8) "DOUBLE_QUOTED_STRING",
        (pANTLR3_UINT8) "EOL",
        (pANTLR3_UINT8) "EXPONENT",
        (pANTLR3_UINT8) "FLOAT",
        (pANTLR3_UINT8) "GLOBAL_",
        (pANTLR3_UINT8) "INAPPLICABLE",
        (pANTLR3_UINT8) "INTEGER",
        (pANTLR3_UINT8) "LOOP",
        (pANTLR3_UINT8) "LOOP_",
        (pANTLR3_UINT8) "NON_BLANK_CHAR",
        (pANTLR3_UINT8) "NON_BLANK_CHAR_",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "NUMERIC",
        (pANTLR3_UINT8) "ORDINARY_CHAR",
        (pANTLR3_UINT8) "SAVE",
        (pANTLR3_UINT8) "SAVE_",
        (pANTLR3_UINT8) "SAVE_FRAME_HEADING",
        (pANTLR3_UINT8) "SEMI_COLON_TEXT_FIELD",
        (pANTLR3_UINT8) "SINGLE_QUOTE",
        (pANTLR3_UINT8) "SINGLE_QUOTED_STRING",
        (pANTLR3_UINT8) "STOP_",
        (pANTLR3_UINT8) "TAG",
        (pANTLR3_UINT8) "TAG_VALUE_PAIR",
        (pANTLR3_UINT8) "TEXT_LEAD_CHAR",
        (pANTLR3_UINT8) "UNKNOWN",
        (pANTLR3_UINT8) "UNQUOTED_STRING",
        (pANTLR3_UINT8) "UNSIGNED_INTEGER",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "'u001a'",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'?'"
       };


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pcifWalker_parseStack
 */
void
pcifWalker_parsePop(pcifWalker ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
        // If the user supplied the scope entries with a free function,then call it first
        //
    if  (SCOPE_TOP(parse)->free != NULL)
        {
        SCOPE_TOP(parse)->free(SCOPE_TOP(parse));
        }

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pcifWalker_parseStack_limit--;
    SCOPE_TOP(parse) = (pcifWalker_parse_SCOPE)(ctx->pcifWalker_parseStack->get(ctx->pcifWalker_parseStack, ctx->pcifWalker_parseStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pcifWalker_data_itemsStack
 */
void
pcifWalker_data_itemsPop(pcifWalker ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
        // If the user supplied the scope entries with a free function,then call it first
        //
    if  (SCOPE_TOP(data_items)->free != NULL)
        {
        SCOPE_TOP(data_items)->free(SCOPE_TOP(data_items));
        }

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pcifWalker_data_itemsStack_limit--;
    SCOPE_TOP(data_items) = (pcifWalker_data_items_SCOPE)(ctx->pcifWalker_data_itemsStack->get(ctx->pcifWalker_data_itemsStack, ctx->pcifWalker_data_itemsStack_limit - 1));
}



// Forward declare the locally static matching functions we have generated.
//
static
 void
        parse    (pcifWalker ctx, ucif::builder_base* builder_);
static
 void
        cif    (pcifWalker ctx);
static
 void
        loop_body    (pcifWalker ctx);
static
 void
        save_frame    (pcifWalker ctx);
static
 void
        data_items    (pcifWalker ctx);
static
 cifWalker_data_block_heading_return
        data_block_heading    (pcifWalker ctx);
static
 void
        data_block    (pcifWalker ctx);
static
 void
        loop_header    (pcifWalker ctx);
static
 void
        inapplicable    (pcifWalker ctx);
static
 void
        unknown    (pcifWalker ctx);
static
 cifWalker_value_return
        value    (pcifWalker ctx);
static
 void
        char_string    (pcifWalker ctx);
static
 void
        text_field    (pcifWalker ctx);
static void     cifWalkerFree(pcifWalker ctx);
static void     cifWalkerReset (pcifWalker ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static  void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "cifWalker.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
        return fileName;
}
/** \brief Create a new cifWalker parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcifWalker
cifWalkerNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
        // See if we can create a new parser with the standard constructor
        //
        return cifWalkerNewSSD(instream, NULL);
}

/** \brief Create a new cifWalker parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcifWalker
cifWalkerNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pcifWalker ctx;         /* Context structure we will build and return   */

    ctx = (pcifWalker) ANTLR3_CALLOC(1, sizeof(cifWalker));

    if  (ctx == NULL)
    {
                // Failed to allocate memory for parser context
                //
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in cifWalker.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser            = antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Install the implementation of our cifWalker interface
     */
    ctx->parse  = parse;
    ctx->cif    = cif;
    ctx->loop_body      = loop_body;
    ctx->save_frame     = save_frame;
    ctx->data_items     = data_items;
    ctx->data_block_heading     = data_block_heading;
    ctx->data_block     = data_block;
    ctx->loop_header    = loop_header;
    ctx->inapplicable   = inapplicable;
    ctx->unknown        = unknown;
    ctx->value  = value;
    ctx->char_string    = char_string;
    ctx->text_field     = text_field;
    ctx->free                   = cifWalkerFree;
    ctx->reset                  = cifWalkerReset;
    ctx->getGrammarFileName     = getGrammarFileName;

    /* Install the scope pushing methods.
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pcifWalker_parsePush     = pcifWalker_parsePush;
    ctx->pcifWalker_parseStack    = antlr3StackNew(0);
    ctx->pcifWalker_parseStack_limit    = 0;
    ctx->pcifWalker_parseTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->pcifWalker_data_itemsPush     = pcifWalker_data_itemsPush;
    ctx->pcifWalker_data_itemsStack    = antlr3StackNew(0);
    ctx->pcifWalker_data_itemsStack_limit    = 0;
    ctx->pcifWalker_data_itemsTop      = NULL;




    /* Install the token table
     */
    PSRSTATE->tokenNames   = cifWalkerTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
cifWalkerReset (pcifWalker ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 cifWalkerFree(pcifWalker ctx)
 {
    /* Free any scope memory
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pcifWalker_parseStack->free(ctx->pcifWalker_parseStack);


    /* ruleAttributeScope(scope)
     */
    ctx->pcifWalker_data_itemsStack->free(ctx->pcifWalker_data_itemsStack);



        // Free this parser
        //
    ctx->pTreeParser->free(ctx->pTreeParser);

    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this
tree parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return cifWalkerTokenNames;
}


      std::string to_std_string(pANTLR3_BASE_TREE node) {
        pANTLR3_COMMON_TOKEN token = ((pANTLR3_COMMON_TREE)(node->super))->token;
        ANTLR3_MARKER start = token->getStartIndex(token);
        ANTLR3_MARKER stop = token->getStopIndex(token);
        std::string str((const char*)start, stop-start+1);
        if ((str[0] == '\'' && str[str.size()-1] == '\'') ||
          (str[0] == '"' && str[str.size()-1] == '"'))
        { str = str.substr(1, str.size()-2); }
        return str;
      }


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cif_in_parse75  */
static  ANTLR3_BITWORD FOLLOW_cif_in_parse75_bits[]     = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cif_in_parse75        = { FOLLOW_cif_in_parse75_bits, 1       };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_data_block_in_cif88  */
static  ANTLR3_BITWORD FOLLOW_data_block_in_cif88_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_data_block_in_cif88   = { FOLLOW_data_block_in_cif88_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_loop_body108  */
static  ANTLR3_BITWORD FOLLOW_value_in_loop_body108_bits[]      = { ANTLR3_UINT64_LIT(0x0000002042040022) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_loop_body108 = { FOLLOW_value_in_loop_body108_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SAVE_in_save_frame127  */
static  ANTLR3_BITWORD FOLLOW_SAVE_in_save_frame127_bits[]      = { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SAVE_in_save_frame127 = { FOLLOW_SAVE_in_save_frame127_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SAVE_FRAME_HEADING_in_save_frame129  */
static  ANTLR3_BITWORD FOLLOW_SAVE_FRAME_HEADING_in_save_frame129_bits[]        = { ANTLR3_UINT64_LIT(0x0000000800100000) };
static  ANTLR3_BITSET_LIST FOLLOW_SAVE_FRAME_HEADING_in_save_frame129   = { FOLLOW_SAVE_FRAME_HEADING_in_save_frame129_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_data_items_in_save_frame137  */
static  ANTLR3_BITWORD FOLLOW_data_items_in_save_frame137_bits[]        = { ANTLR3_UINT64_LIT(0x0000000800100008) };
static  ANTLR3_BITSET_LIST FOLLOW_data_items_in_save_frame137   = { FOLLOW_data_items_in_save_frame137_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TAG_VALUE_PAIR_in_data_items173  */
static  ANTLR3_BITWORD FOLLOW_TAG_VALUE_PAIR_in_data_items173_bits[]    = { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TAG_VALUE_PAIR_in_data_items173       = { FOLLOW_TAG_VALUE_PAIR_in_data_items173_bits, 1      };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TAG_in_data_items175  */
static  ANTLR3_BITWORD FOLLOW_TAG_in_data_items175_bits[]       = { ANTLR3_UINT64_LIT(0x0000002042040020) };
static  ANTLR3_BITSET_LIST FOLLOW_TAG_in_data_items175  = { FOLLOW_TAG_in_data_items175_bits, 1 };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_data_items177  */
static  ANTLR3_BITWORD FOLLOW_value_in_data_items177_bits[]     = { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_data_items177        = { FOLLOW_value_in_data_items177_bits, 1       };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOOP_in_data_items187  */
static  ANTLR3_BITWORD FOLLOW_LOOP_in_data_items187_bits[]      = { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LOOP_in_data_items187 = { FOLLOW_LOOP_in_data_items187_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_loop_header_in_data_items189  */
static  ANTLR3_BITWORD FOLLOW_loop_header_in_data_items189_bits[]       = { ANTLR3_UINT64_LIT(0x0000002042040020) };
static  ANTLR3_BITSET_LIST FOLLOW_loop_header_in_data_items189  = { FOLLOW_loop_header_in_data_items189_bits, 1 };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_loop_body_in_data_items191  */
static  ANTLR3_BITWORD FOLLOW_loop_body_in_data_items191_bits[] = { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_loop_body_in_data_items191    = { FOLLOW_loop_body_in_data_items191_bits, 1   };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DATA_BLOCK_in_data_block225  */
static  ANTLR3_BITWORD FOLLOW_DATA_BLOCK_in_data_block225_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DATA_BLOCK_in_data_block225   = { FOLLOW_DATA_BLOCK_in_data_block225_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_data_block_heading_in_data_block227  */
static  ANTLR3_BITWORD FOLLOW_data_block_heading_in_data_block227_bits[]        = { ANTLR3_UINT64_LIT(0x0000000808100008) };
static  ANTLR3_BITSET_LIST FOLLOW_data_block_heading_in_data_block227   = { FOLLOW_data_block_heading_in_data_block227_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_data_items_in_data_block233  */
static  ANTLR3_BITWORD FOLLOW_data_items_in_data_block233_bits[]        = { ANTLR3_UINT64_LIT(0x0000000808100008) };
static  ANTLR3_BITSET_LIST FOLLOW_data_items_in_data_block233   = { FOLLOW_data_items_in_data_block233_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_save_frame_in_data_block236  */
static  ANTLR3_BITWORD FOLLOW_save_frame_in_data_block236_bits[]        = { ANTLR3_UINT64_LIT(0x0000000008000008) };
static  ANTLR3_BITSET_LIST FOLLOW_save_frame_in_data_block236   = { FOLLOW_save_frame_in_data_block236_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOOP__in_loop_header251  */
static  ANTLR3_BITWORD FOLLOW_LOOP__in_loop_header251_bits[]    = { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LOOP__in_loop_header251       = { FOLLOW_LOOP__in_loop_header251_bits, 1      };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TAG_in_loop_header255  */
static  ANTLR3_BITWORD FOLLOW_TAG_in_loop_header255_bits[]      = { ANTLR3_UINT64_LIT(0x0000000400000008) };
static  ANTLR3_BITSET_LIST FOLLOW_TAG_in_loop_header255 = { FOLLOW_TAG_in_loop_header255_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_inapplicable278  */
static  ANTLR3_BITWORD FOLLOW_42_in_inapplicable278_bits[]      = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_inapplicable278 = { FOLLOW_42_in_inapplicable278_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_unknown287  */
static  ANTLR3_BITWORD FOLLOW_43_in_unknown287_bits[]   = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_unknown287      = { FOLLOW_43_in_unknown287_bits, 1     };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INAPPLICABLE_in_value298  */
static  ANTLR3_BITWORD FOLLOW_INAPPLICABLE_in_value298_bits[]   = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INAPPLICABLE_in_value298      = { FOLLOW_INAPPLICABLE_in_value298_bits, 1     };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNKNOWN_in_value302  */
static  ANTLR3_BITWORD FOLLOW_UNKNOWN_in_value302_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UNKNOWN_in_value302   = { FOLLOW_UNKNOWN_in_value302_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERIC_in_value306  */
static  ANTLR3_BITWORD FOLLOW_NUMERIC_in_value306_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERIC_in_value306   = { FOLLOW_NUMERIC_in_value306_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_char_string_in_value310  */
static  ANTLR3_BITWORD FOLLOW_char_string_in_value310_bits[]    = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_char_string_in_value310       = { FOLLOW_char_string_in_value310_bits, 1      };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_field_in_value314  */
static  ANTLR3_BITWORD FOLLOW_text_field_in_value314_bits[]     = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_text_field_in_value314        = { FOLLOW_text_field_in_value314_bits, 1       };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHAR_STRING_in_char_string327  */
static  ANTLR3_BITWORD FOLLOW_CHAR_STRING_in_char_string327_bits[]      = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHAR_STRING_in_char_string327 = { FOLLOW_CHAR_STRING_in_char_string327_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_COLON_TEXT_FIELD_in_text_field338  */
static  ANTLR3_BITWORD FOLLOW_SEMI_COLON_TEXT_FIELD_in_text_field338_bits[]     = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_COLON_TEXT_FIELD_in_text_field338        = { FOLLOW_SEMI_COLON_TEXT_FIELD_in_text_field338_bits, 1       };


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start parse
 * cifWalker.g:50:1: parse[ucif::builder_base* builder_] : cif ;
 */
static void
parse(pcifWalker ctx, ucif::builder_base* builder_)
{
    /* Initialize rule variables
     */
    ctx->pcifWalker_parseTop = pcifWalker_parsePush(ctx);
     (SCOPE_TOP(parse))->builder= builder_;
    {
        // cifWalker.g:54:3: ( cif )
        // cifWalker.g:54:5: cif
        {
            FOLLOWPUSH(FOLLOW_cif_in_parse75);
            cif(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparseEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparseEx; /* Prevent compiler warnings */
    ruleparseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    pcifWalker_parsePop(ctx);

    return ;
}
/* $ANTLR end parse */

/**
 * $ANTLR start cif
 * cifWalker.g:59:1: cif : ( data_block )* ;
 */
static void
cif(pcifWalker ctx)
{
    /* Initialize rule variables
     */

    {
        // cifWalker.g:60:3: ( ( data_block )* )
        // cifWalker.g:60:5: ( data_block )*
        {
            // cifWalker.g:60:5: ( data_block )*

            for (;;)
            {
                int alt1=2;
                switch ( LA(1) )
                {
                case DATA_BLOCK:
                        {
                                alt1=1;
                        }
                    break;

                }

                switch (alt1)
                {
                case 1:
                    // cifWalker.g:60:5: data_block
                    {
                        FOLLOWPUSH(FOLLOW_data_block_in_cif88);
                        data_block(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto rulecifEx;
                        }


                    }
                    break;

                default:
                    goto loop1; /* break out of the loop */
                    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecifEx; /* Prevent compiler warnings */
    rulecifEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end cif */

/**
 * $ANTLR start loop_body
 * cifWalker.g:63:1: loop_body : ( value )+ ;
 */
static void
loop_body(pcifWalker ctx)
{
    cifWalker_value_return value1;
    #undef      RETURN_TYPE_value1
    #define     RETURN_TYPE_value1 cifWalker_value_return

    /* Initialize rule variables
     */

    {
        // cifWalker.g:64:3: ( ( value )+ )
        // cifWalker.g:65:5: ( value )+
        {
            // cifWalker.g:65:5: ( value )+
            {
                int cnt2=0;

                for (;;)
                {
                    int alt2=2;
                switch ( LA(1) )
                {
                case CHAR_STRING:
                case INAPPLICABLE:
                case NUMERIC:
                case SEMI_COLON_TEXT_FIELD:
                case UNKNOWN:
                        {
                                alt2=1;
                        }
                    break;

                }

                switch (alt2)
                {
                    case 1:
                        // cifWalker.g:65:7: value
                        {
                            FOLLOWPUSH(FOLLOW_value_in_loop_body108);
                            value1=value(ctx);

                            FOLLOWPOP();
                            if  (HASEXCEPTION())
                            {
                                goto ruleloop_bodyEx;
                            }


                            {
                                 ((SCOPE_TOP(data_items))->curr_loop_values)->push_back(to_std_string((value1.start)));
                            }


                        }
                        break;

                    default:

                        if ( cnt2 >= 1 )
                        {
                            goto loop2;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleloop_bodyEx;
                }
                cnt2++;
                }
                loop2: ;        /* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleloop_bodyEx; /* Prevent compiler warnings */
    ruleloop_bodyEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end loop_body */

/**
 * $ANTLR start save_frame
 * cifWalker.g:70:1: save_frame : ^( SAVE SAVE_FRAME_HEADING ( data_items )+ ) ;
 */
static void
save_frame(pcifWalker ctx)
{
    pANTLR3_BASE_TREE    SAVE_FRAME_HEADING2;

    /* Initialize rule variables
     */

    SAVE_FRAME_HEADING2       = NULL;

    {
        // cifWalker.g:71:3: ( ^( SAVE SAVE_FRAME_HEADING ( data_items )+ ) )
        // cifWalker.g:71:5: ^( SAVE SAVE_FRAME_HEADING ( data_items )+ )
        {
             MATCHT(SAVE, &FOLLOW_SAVE_in_save_frame127);
            if  (HASEXCEPTION())
            {
                goto rulesave_frameEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulesave_frameEx;
            }

            SAVE_FRAME_HEADING2 = (pANTLR3_BASE_TREE) MATCHT(SAVE_FRAME_HEADING, &FOLLOW_SAVE_FRAME_HEADING_in_save_frame129);
            if  (HASEXCEPTION())
            {
                goto rulesave_frameEx;
            }


            {
                 ((SCOPE_TOP(parse))->builder)->start_save_frame(to_std_string(SAVE_FRAME_HEADING2));
            }


            // cifWalker.g:73:3: ( data_items )+
            {
                int cnt3=0;

                for (;;)
                {
                    int alt3=2;
                switch ( LA(1) )
                {
                case LOOP:
                case TAG_VALUE_PAIR:
                        {
                                alt3=1;
                        }
                    break;

                }

                switch (alt3)
                {
                    case 1:
                        // cifWalker.g:73:5: data_items
                        {
                            FOLLOWPUSH(FOLLOW_data_items_in_save_frame137);
                            data_items(ctx);

                            FOLLOWPOP();
                            if  (HASEXCEPTION())
                            {
                                goto rulesave_frameEx;
                            }


                        }
                        break;

                    default:

                        if ( cnt3 >= 1 )
                        {
                            goto loop3;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto rulesave_frameEx;
                }
                cnt3++;
                }
                loop3: ;        /* Jump to here if this rule does not match */
            }

            {
                 ((SCOPE_TOP(parse))->builder)->end_save_frame();
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulesave_frameEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulesave_frameEx; /* Prevent compiler warnings */
    rulesave_frameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end save_frame */

/**
 * $ANTLR start data_items
 * cifWalker.g:78:1: data_items : ( ^( TAG_VALUE_PAIR TAG value ) | ^( LOOP loop_header loop_body ) );
 */
static void
data_items(pcifWalker ctx)
{
    pANTLR3_BASE_TREE    TAG3;
    cifWalker_value_return value4;
    #undef      RETURN_TYPE_value4
    #define     RETURN_TYPE_value4 cifWalker_value_return

    /* Initialize rule variables
     */
    ctx->pcifWalker_data_itemsTop = pcifWalker_data_itemsPush(ctx);

      (SCOPE_TOP(data_items))->curr_loop_values= ((SCOPE_TOP(parse))->builder)->new_array();
      (SCOPE_TOP(data_items))->curr_loop_headers= ((SCOPE_TOP(parse))->builder)->new_array();

    TAG3       = NULL;

    {
        {
            //  cifWalker.g:91:3: ( ^( TAG_VALUE_PAIR TAG value ) | ^( LOOP loop_header loop_body ) )

            ANTLR3_UINT32 alt4;

            alt4=2;

            switch ( LA(1) )
            {
            case TAG_VALUE_PAIR:
                {
                        alt4=1;
                }
                break;
            case LOOP:
                {
                        alt4=2;
                }
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 4;
                EXCEPTION->state        = 0;


                goto ruledata_itemsEx;

            }

            switch (alt4)
            {
                case 1:
                    // cifWalker.g:91:6: ^( TAG_VALUE_PAIR TAG value )
                    {
                         MATCHT(TAG_VALUE_PAIR, &FOLLOW_TAG_VALUE_PAIR_in_data_items173);
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }


                        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }

                        TAG3 = (pANTLR3_BASE_TREE) MATCHT(TAG, &FOLLOW_TAG_in_data_items175);
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }


                        FOLLOWPUSH(FOLLOW_value_in_data_items177);
                        value4=value(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }


                        MATCHT(ANTLR3_TOKEN_UP, NULL);
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }



                        {

                              ((SCOPE_TOP(parse))->builder)->add_data_item(
                                to_std_string(TAG3),
                                to_std_string((value4.start)));

                        }


                    }
                    break;
                case 2:
                    // cifWalker.g:97:5: ^( LOOP loop_header loop_body )
                    {
                         MATCHT(LOOP, &FOLLOW_LOOP_in_data_items187);
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }


                        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }

                        FOLLOWPUSH(FOLLOW_loop_header_in_data_items189);
                        loop_header(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }


                        FOLLOWPUSH(FOLLOW_loop_body_in_data_items191);
                        loop_body(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }


                        MATCHT(ANTLR3_TOKEN_UP, NULL);
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }



                        {

                              ucif::array_wrapper_base* values = (SCOPE_TOP(data_items))->curr_loop_values;
                              int n_cols = (SCOPE_TOP(data_items))->curr_loop_headers->size();
                              if (values->size() % n_cols != 0) {
                                std::string msg = "Wrong number of data items for loop containing ";
                                msg += (*(SCOPE_TOP(data_items))->curr_loop_headers)[0];
                                CTX->errors->push_back(msg);
                              }
                              else {
                                ((SCOPE_TOP(parse))->builder)->add_loop(*(SCOPE_TOP(data_items))->curr_loop_headers, *values);
                              }

                        }


                    }
                    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledata_itemsEx; /* Prevent compiler warnings */
    ruledata_itemsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                      delete (SCOPE_TOP(data_items))->curr_loop_values;
                      delete (SCOPE_TOP(data_items))->curr_loop_headers;

                }
            }


    pcifWalker_data_itemsPop(ctx);

    return ;
}
/* $ANTLR end data_items */

/**
 * $ANTLR start data_block_heading
 * cifWalker.g:112:1: data_block_heading : ( DATA_BLOCK_HEADING | GLOBAL_ );
 */
static cifWalker_data_block_heading_return
data_block_heading(pcifWalker ctx)
{
    cifWalker_data_block_heading_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // cifWalker.g:113:3: ( DATA_BLOCK_HEADING | GLOBAL_ )
        // cifWalker.g:
        {
            if ( LA(1) == DATA_BLOCK_HEADING || LA(1) == GLOBAL_ )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                goto ruledata_block_headingEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledata_block_headingEx; /* Prevent compiler warnings */
    ruledata_block_headingEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end data_block_heading */

/**
 * $ANTLR start data_block
 * cifWalker.g:116:1: data_block : ^( DATA_BLOCK data_block_heading ( data_items )* ( save_frame )* ) ;
 */
static void
data_block(pcifWalker ctx)
{
    cifWalker_data_block_heading_return data_block_heading5;
    #undef      RETURN_TYPE_data_block_heading5
    #define     RETURN_TYPE_data_block_heading5 cifWalker_data_block_heading_return

    /* Initialize rule variables
     */

    {
        // cifWalker.g:117:3: ( ^( DATA_BLOCK data_block_heading ( data_items )* ( save_frame )* ) )
        // cifWalker.g:117:5: ^( DATA_BLOCK data_block_heading ( data_items )* ( save_frame )* )
        {
             MATCHT(DATA_BLOCK, &FOLLOW_DATA_BLOCK_in_data_block225);
            if  (HASEXCEPTION())
            {
                goto ruledata_blockEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruledata_blockEx;
            }

            FOLLOWPUSH(FOLLOW_data_block_heading_in_data_block227);
            data_block_heading5=data_block_heading(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledata_blockEx;
            }


            {
                 ((SCOPE_TOP(parse))->builder)->add_data_block(to_std_string((data_block_heading5.start)));
            }


            // cifWalker.g:119:3: ( data_items )*

            for (;;)
            {
                int alt5=2;
                switch ( LA(1) )
                {
                case LOOP:
                case TAG_VALUE_PAIR:
                        {
                                alt5=1;
                        }
                    break;

                }

                switch (alt5)
                {
                case 1:
                    // cifWalker.g:119:3: data_items
                    {
                        FOLLOWPUSH(FOLLOW_data_items_in_data_block233);
                        data_items(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_blockEx;
                        }


                    }
                    break;

                default:
                    goto loop5; /* break out of the loop */
                    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


            // cifWalker.g:119:15: ( save_frame )*

            for (;;)
            {
                int alt6=2;
                switch ( LA(1) )
                {
                case SAVE:
                        {
                                alt6=1;
                        }
                    break;

                }

                switch (alt6)
                {
                case 1:
                    // cifWalker.g:119:15: save_frame
                    {
                        FOLLOWPUSH(FOLLOW_save_frame_in_data_block236);
                        save_frame(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_blockEx;
                        }


                    }
                    break;

                default:
                    goto loop6; /* break out of the loop */
                    break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruledata_blockEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruledata_blockEx; /* Prevent compiler warnings */
    ruledata_blockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end data_block */

/**
 * $ANTLR start loop_header
 * cifWalker.g:123:1: loop_header : ^( LOOP_ ( TAG )+ ) ;
 */
static void
loop_header(pcifWalker ctx)
{
    pANTLR3_BASE_TREE    TAG6;

    /* Initialize rule variables
     */

    TAG6       = NULL;

    {
        // cifWalker.g:124:3: ( ^( LOOP_ ( TAG )+ ) )
        // cifWalker.g:124:5: ^( LOOP_ ( TAG )+ )
        {
             MATCHT(LOOP_, &FOLLOW_LOOP__in_loop_header251);
            if  (HASEXCEPTION())
            {
                goto ruleloop_headerEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleloop_headerEx;
            }

            // cifWalker.g:124:13: ( TAG )+
            {
                int cnt7=0;

                for (;;)
                {
                    int alt7=2;
                switch ( LA(1) )
                {
                case TAG:
                        {
                                alt7=1;
                        }
                    break;

                }

                switch (alt7)
                {
                    case 1:
                        // cifWalker.g:124:15: TAG
                        {
                            TAG6 = (pANTLR3_BASE_TREE) MATCHT(TAG, &FOLLOW_TAG_in_loop_header255);
                            if  (HASEXCEPTION())
                            {
                                goto ruleloop_headerEx;
                            }


                            {
                                 ((SCOPE_TOP(data_items))->curr_loop_headers)->push_back(to_std_string(TAG6));
                            }


                        }
                        break;

                    default:

                        if ( cnt7 >= 1 )
                        {
                            goto loop7;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleloop_headerEx;
                }
                cnt7++;
                }
                loop7: ;        /* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleloop_headerEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleloop_headerEx; /* Prevent compiler warnings */
    ruleloop_headerEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end loop_header */

/**
 * $ANTLR start inapplicable
 * cifWalker.g:133:1: inapplicable : '.' ;
 */
static void
inapplicable(pcifWalker ctx)
{
    /* Initialize rule variables
     */

    {
        // cifWalker.g:134:3: ( '.' )
        // cifWalker.g:134:5: '.'
        {
             MATCHT(42, &FOLLOW_42_in_inapplicable278);
            if  (HASEXCEPTION())
            {
                goto ruleinapplicableEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinapplicableEx; /* Prevent compiler warnings */
    ruleinapplicableEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end inapplicable */

/**
 * $ANTLR start unknown
 * cifWalker.g:136:1: unknown : '?' ;
 */
static void
unknown(pcifWalker ctx)
{
    /* Initialize rule variables
     */

    {
        // cifWalker.g:136:9: ( '?' )
        // cifWalker.g:136:11: '?'
        {
             MATCHT(43, &FOLLOW_43_in_unknown287);
            if  (HASEXCEPTION())
            {
                goto ruleunknownEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunknownEx; /* Prevent compiler warnings */
    ruleunknownEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end unknown */

/**
 * $ANTLR start value
 * cifWalker.g:138:1: value : ( INAPPLICABLE | UNKNOWN | NUMERIC | char_string | text_field );
 */
static cifWalker_value_return
value(pcifWalker ctx)
{
    cifWalker_value_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        {
            //  cifWalker.g:139:3: ( INAPPLICABLE | UNKNOWN | NUMERIC | char_string | text_field )

            ANTLR3_UINT32 alt8;

            alt8=5;

            switch ( LA(1) )
            {
            case INAPPLICABLE:
                {
                        alt8=1;
                }
                break;
            case UNKNOWN:
                {
                        alt8=2;
                }
                break;
            case NUMERIC:
                {
                        alt8=3;
                }
                break;
            case CHAR_STRING:
                {
                        alt8=4;
                }
                break;
            case SEMI_COLON_TEXT_FIELD:
                {
                        alt8=5;
                }
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 8;
                EXCEPTION->state        = 0;


                goto rulevalueEx;

            }

            switch (alt8)
            {
                case 1:
                    // cifWalker.g:139:5: INAPPLICABLE
                    {
                         MATCHT(INAPPLICABLE, &FOLLOW_INAPPLICABLE_in_value298);
                        if  (HASEXCEPTION())
                        {
                            goto rulevalueEx;
                        }


                    }
                    break;
                case 2:
                    // cifWalker.g:139:20: UNKNOWN
                    {
                         MATCHT(UNKNOWN, &FOLLOW_UNKNOWN_in_value302);
                        if  (HASEXCEPTION())
                        {
                            goto rulevalueEx;
                        }


                    }
                    break;
                case 3:
                    // cifWalker.g:139:30: NUMERIC
                    {
                         MATCHT(NUMERIC, &FOLLOW_NUMERIC_in_value306);
                        if  (HASEXCEPTION())
                        {
                            goto rulevalueEx;
                        }


                    }
                    break;
                case 4:
                    // cifWalker.g:139:40: char_string
                    {
                        FOLLOWPUSH(FOLLOW_char_string_in_value310);
                        char_string(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto rulevalueEx;
                        }


                    }
                    break;
                case 5:
                    // cifWalker.g:139:54: text_field
                    {
                        FOLLOWPUSH(FOLLOW_text_field_in_value314);
                        text_field(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto rulevalueEx;
                        }


                    }
                    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulevalueEx; /* Prevent compiler warnings */
    rulevalueEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end value */

/**
 * $ANTLR start char_string
 * cifWalker.g:142:1: char_string : CHAR_STRING ;
 */
static void
char_string(pcifWalker ctx)
{
    /* Initialize rule variables
     */

    {
        // cifWalker.g:143:3: ( CHAR_STRING )
        // cifWalker.g:143:5: CHAR_STRING
        {
             MATCHT(CHAR_STRING, &FOLLOW_CHAR_STRING_in_char_string327);
            if  (HASEXCEPTION())
            {
                goto rulechar_stringEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulechar_stringEx; /* Prevent compiler warnings */
    rulechar_stringEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end char_string */

/**
 * $ANTLR start text_field
 * cifWalker.g:145:1: text_field : SEMI_COLON_TEXT_FIELD ;
 */
static void
text_field(pcifWalker ctx)
{
    /* Initialize rule variables
     */

    {
        // cifWalker.g:146:3: ( SEMI_COLON_TEXT_FIELD )
        // cifWalker.g:146:5: SEMI_COLON_TEXT_FIELD
        {
             MATCHT(SEMI_COLON_TEXT_FIELD, &FOLLOW_SEMI_COLON_TEXT_FIELD_in_text_field338);
            if  (HASEXCEPTION())
            {
                goto ruletext_fieldEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletext_fieldEx; /* Prevent compiler warnings */
    ruletext_fieldEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end text_field */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */

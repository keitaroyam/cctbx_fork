===============
 phil overview
===============

Phil (Python-based hierarchical interchange language) is a
comprehensive system for the management of application parameters and,
to some degree, inputs. Many applications use command-line options as
a user interface (e.g. Python's optparse, a.k.a Optik). This approach
works well for small applications, but has it limitations for more
complex applications with a large set of parameters to direct the
underlying algorithms.

A simple Phil file as presented to the user may look like this::

  minimization.input {
    file_name = experiment.dat
    labels = x2 y2
  }
  minimization.output {
    model_file = final.mdl
    plot_file = None
  }
  minimization.parameters {
    method = *bfgs conjugate_gradient
    max_iterations = 10
  }

Phil is designed with a minimal syntax. An important goal is to
enable users to get started just by looking at defaults and examples,
without having to read documentation.

The Phil syntax has only two main elements, ``phil.definition`` (e.g.
``max_iterations = 10`` and ``phil.scope`` (e.g. ``minimization.input { }``).
To make this syntax as user-friendly as possible, strings
do not have to be quoted and, unlike Python, indentation is not
syntactically significant. E.g. this::

  minimization.input {
  file_name="experiment.dat"
  labels="x2" "y2"
  }

is equivalent to the corresponding definitions above.

Scopes can be nested recursively. The number of nesting levels is
limited only by Python's recursion limit (default 1000). To maximize
convenience, nested scopes can be defined in two equivalent ways.
For example::

  minimization {
    input {
    }
  }

is equivalent to::

  minimization.input {
  }

Beyond syntax
-------------

Phil is much more than just a parser for a very simple, user-friendly
syntax. Major Phil features are:

  - The concepts of `master files` and `user files`. The syntax
    for the two types of Phil files is identical, but the processed
    Phil files are used in different ways. I.e. the concepts exist
    only at the semantical level. The "look and feel" of the files is
    uniform.

  - Interpretation of command-line arguments as Phil definitions.

  - Merging of (multiple) Phil files and (multiple) Phil definitions
    derived from command-line arguments.

  - Automatic conversion of Phil files to pure Python objects
    which are completely independent of the Phil system. I.e.
    core algorithms using Phil-derived parameter objects do not
    actually have to depend on Phil.

  - The reverse conversion of (potentially modified) pure Python
    objects back to Phil files. This could also be viewed as a Phil
    pretty printer.

  - Shell-like variable substitution using $var and ${var} syntax.

  - ``include`` syntax to merge Phil files at the parser level,
    or to import Phil objects from other Python scripts.

Master files
------------

Master files are written by the software developer and include
"attributes" for each parameter, such as the type (integer,
floating-point, string, etc.) and support information for graphical
interfaces. For example::

  minimization.parameters
    .help = "Selection and tuning of minimization algorithm."
    .expert_level = 1
  {
    method = *bfgs conjugate_gradient
      .type = choice
    max_iterations = 10
      .type = int
      .input_size = 8
  }

The is the last part of the output of this command::

  libtbx.phil --show-some-attributes example.params

Run this command with ``--show-all-attributes`` to see the full set
of ``definition`` and ``scope`` attributes. This output tends to get
very long, but end-users don't have to be aware of this, and even
programmers only have to deal with the attributes they want to change.

User files
----------

User files are typically generated by the application. E.g.

  minimization.quick --show_defaults

will process its master file and show only the most
relevant parameters, classified by the software developer as
``.expert_level = 0`` (default). E.g. the ``minimization.parameters``
scope in the example above is not shown. The attributes are also
not shown. Therefore the output is much shorter compared to the
``libtbx.phil --show-some-attributes`` output above.

Command-line arguments + Phil
-----------------------------

In theory the user could save and edit the generated parameter files.
However, in many practical situations this manual step can be
avoided. Phil is designed with the idea that the application inspects
all input files and uses the information found to fill in the blanks
automatically. This is not only convenient, but also eliminates
the possiblity of typing errors. In addition, the user can specify
parameters directly on the command line, and this information is also
use to fill in the blanks.

Command-line arguments that are not file names or options prefixed
with ``--`` (like ``--show_defaults`` above) should be given to Phil
for examination. E.g., this is a possible command::

  minimization.quick experiment.dat output.plot_file=plot.pdf

First the application should check if an argument is the name of a
file that can be opened. Assume this succeeds for the first argument,
so the processing of this argument is finished. Assume further that a
file with the name ``output.plot_file=plot.pdf`` does not exist. This
argument will therefore be interpreted with Phil. The next section
presents an example.

Merging of Phil objects ("fetch")
---------------------------------

The Phil parser converts master files, user files and command line
arguments to uniform Phil objects which can be merged to generate a
combined set of "working" parameters used in running the application.
We demonstrate this by way of a simple, self-contained Python script
with embedded Phil syntax::

  ## extract code begin: doc_code.py

  import libtbx.phil

  master_phil = libtbx.phil.parse("""
    minimization.input {
      file_name = None
        .type=str
      labels = None
        .type=strings
    }
    """)

  user_phil = libtbx.phil.parse("""
    minimization.input {
      file_name = experiment.dat
    }
    """)

  command_line_phil = libtbx.phil.parse(
    "minimization.input.labels=x1 x2")

  working_phil = master_phil.fetch(
    sources=[user_phil, command_line_phil])
  working_phil.show()

  ## extract code end

``master_phil`` defines all available parameters including the
type information. ``user_phil`` overrides the default ``file_name``
assignment but leaves the ``labels`` undefined. These are defined
by a (fake) command-line argument. All inputs are merged via
``master_phil.fetch()``. ``working_phil.show()`` produces::

  minimization.input {
    file_name = experiment.dat
    labels = x1 x2
  }

Having to type in fully qualified parameter names (e.g.
``minimization.input.labels``) can be very inconvenient. Therefore
Phil includes support for matching parameter names of command-line
arguments as substrings to the parameter names in the master files::

  ## extract code begin: doc_code.py

  import libtbx.phil.command_line

  argument_interpreter = libtbx.phil.command_line.argument_interpreter(
    master_phil=master_phil,
    home_scope="minimization")

  command_line_phil = argument_interpreter.process(
    arg="minimization.input.labels=x1 x2")

  ## extract code end

This works even if the user writes just ``labels=x1 x2`` or even
``put.lab=x1 x2``. The only requirement is that the substring leads
to a unique match in the master file. Otherwise Phil produces a helpful
error message. For example::

  argument_interpreter.process("a=x1 x2")

leads to::

  Sorry: Ambiguous parameter definition: a = x1 x2
  Best matches:
    minimization.input.file_name
    minimization.input.labels

The user can cut-and-paste the desired parameter into the command
line for another trial to run the application.

Conversion of Phil objects to pure Python objects ("extract")
-------------------------------------------------------------

The Phil parser produces objects that preserve most information
generated in the parsing process, such as line numbers and parameter
attributes. While this information is very useful for pretty printing
(e.g. to archive the working parameters) and the automatic generation
of graphical user interfaces, it is only a burden in the context of
core algorithms. Therefore Phil supports "extraction" of light-weight
pure Python objects from the Phil objects. Based on the example above,
this can be achieved with just one line::

  ## extract code begin: doc_code.py

  working_params = working_phil.extract()

  ## extract code end

We can now use the extracted objects in the context of Python::

  ## extract code begin: doc_code.py

  print working_params.minimization.input.file_name
  print working_params.minimization.input.labels

  ## extract code end

Output::

  experiment.dat
  ['x1', 'x2']

``file_name`` is now a simple Python string, and ``labels`` a Python
list of strings.

Conversion of Python objects to Phil objects ("format")
-------------------------------------------------------

Phil also supports the reverse conversion compared to the
previous section, from Python objects to Phil objects. For
example, to change the labels::

  ## extract code begin: doc_code.py

  working_params.minimization.input.labels = ["x3", "y3"]
  modified_phil = master_phil.format(python_object=working_params)
  modified_phil.show()

  ## extract code end

Output::

  minimization.input {
    file_name = "experiment.dat"
    labels = x3 y3
  }

We need to bring in ``master_phil`` again because all the meta
information was lost in the ``working_phil.extract()`` step that
produced ``working_params``. A type-specific converter is used to
produce a string for each Python object.

Extending Phil
--------------

Phil comes with a number of predefined converters used by ``extract()``
and ``format()`` to convert to and from pure Python objects. These
are::

  .type =
    words     retains the "words" produced by the parser
    strings   list of Python strings (also used for .type = None)
    str       combines all words into one string
    path      path name (same as str_converters)
    key       database key (same as str_converters)
    bool      Python bool
    int       Python int
    float     Python float
    choice    string selected from a pre-defined list

It is possible to extend Phil with user-defined converters.
For example::

  ## extract code begin: doc_code.py

  from libtbx.phil import tokenizer

  class upper_converters:

    phil_type = "upper"

    def __str__(self): return self.phil_type

    def from_words(self, words, master):
      s = libtbx.phil.str_from_words(words=words)
      if (s is None): return None
      return s.upper()

    def as_words(self, python_object, master):
      if (python_object is None):
        return [tokenizer.word(value="None")]
      return [tokenizer.word(value=python_object.upper())]

  converter_registry = libtbx.phil.extended_converter_registry(
    additional_converters=[upper_converters])

  ## extract code end

The extended ``converter_registry`` is passed as an additional
argument to Phil's ``parse`` function::

  ## extract code begin: doc_code.py

  master_phil = libtbx.phil.parse(
    input_string="""\
  value = None
    .type = upper
  """,
      converter_registry=converter_registry)
  user_phil = libtbx.phil.parse("value = extracted")
  working_params = master_phil.fetch(source=user_phil).extract()
  print working_params.value

  ## extract code end

The ``print`` statement at the end writes "EXTRACTED". It also goes
the other way, starting with a lower-case Python value::

  ## extract code begin: doc_code.py

  working_params.value = "formatted"
  working_phil = master_phil.format(python_object=working_params)
  working_phil.show()

  ## extract code end

The output of the ``.show()`` call is "value = FORMATTED".

Arbitrary new types can be added to Phil by defining similar
converters. If desired, the pre-defined converters for the basic
types can even be replaced. All converters have to have ``__str__()``,
``from_words()`` and ``as_words()`` methods. More complex converters
may optionally have a non-trivial ``__init__()`` method (an example
is the ``choice_converters`` class in ``libtbx/phil/__init__.py``).

Additional domain-specific converters are best defined in a separate
module, along with a corresponding parse() function using the
extended converter registry as the default. See, for example,
``iotbx/iotbx/phil.py`` in the same ``cctbx`` project that also hosts
``libtbx``.

Variable substitution
---------------------

Phil supports shell-like variable substitution using $var and ${var}
syntax. A few examples say more than many words::

  ## extract code begin: doc_code.py

  var_phil = libtbx.phil.parse("""
    root_name = peak
    file_name = $root_name.mtz
    full_path = $HOME/$file_name
    related_file_name = $(root_name)_data.mtz
    message = "Reading $file_name"
    as_is = ' $file_name '
    """)
  var_phil.fetch(source=var_phil).show()

  ## extract code end

Output::

  root_name = peak
  file_name = "peak.mtz"
  full_path = "/net/cci/rwgk/peak.mtz"
  related_file_name = "peak_data.mtz"
  message = "Reading peak.mtz"
  as_is = ' $file_name '

Note that the variable substitution does not happen during parsing.
The output of ``params.show`` is identical to the input. In the
example above, variables are substituted by the ``fetch()`` method
that we introduced earlier to merge user files given a master file.

Phil odds and ends
------------------

Phil also supports merging of files at the parsing level. The syntax is
simply ``include file file_name``. ``include`` directives may appear inside
scopes to enable hierarchical building of master files without the need
to copy-and-paste large fragments explicitly. Duplication appears only
in automatically generated user files. I.e. the programmer is well
served because a system of master files can be kept free of large-scale
redundancies that are difficult to maintain. At the same time the end
user is well served because the indirections are resolved automatically
and all parameters are presented in one uniform view.

Variable substitution and include directives smell almost like
programming. However, there is a line that Phil is never meant to
cross: flow control is not a part of the syntax. It is hard to imagine
that a fully featured programming language could be syntactically
simpler than Python. For example, there are good reasons why Python
string literals have to be quoted. Otherwise Python scripts would
be full of ``$`` signs because some method is needed to distinguish
strings from variable names. On the other hand, having to quote all
strings in parameter files is a nusiance for users.

Rules for .multiple=True phil objects
-------------------------------------

definition with .multiple=True
  .extract() returns a list of definition values.

scope with .multiple=True
  .extract() returns a list of definition values or scope_extract
  objects (which inherit from Python's built-in list).

With .optional=True (default if not specified explicitly):
  The master definition is NEVER included in the extract result list.
  It does not matter how often it is repeated in the user file.

With .optional=False:
  The master definition is ALWAYS included in the extract result list.
  It is always the first entry in the list, no matter how often
  it is repeated in the user file.

This set of rules is designed to produce easily predictable results
in situations where multiple parameter files are merged (with
master.fetch()), including complete copies of the master file.

.multiple=True examples
-----------------------

In a master file, the first occurrence of a multiple scope is a
"template", all following occurrences are defaults, e.g.::

      group
        .multiple = True
      {
        selection = None
          .type = str
        f_prime = 0
          .type = float
        f_double_prime = 0
          .type = float
        refine = *f_prime *f_double_prime
          .optional = True
          .type = choice(multi=True)
      }

This template will not get extracted, even though it contains defines
that are not None.

The following example shows how to define defaults for multiple scopes::

  mtz_labels
    .multiple=True
  {
    map_type = None
      .type=str
    amplitudes = None
      .type=str
    phases = None
      .type=str
  }
  mtz_labels {
    map_type = 2m*Fobs-D*Fmodel
    amplitudes = 2FOFCWT
    phases = PH2FOFCWT
  }
  mtz_labels {
    map_type = m*Fobs-D*Fmodel
    amplitudes = FOFCWT
    phases = PHFOFCWT
  }

.extract() will return a list with two elements.

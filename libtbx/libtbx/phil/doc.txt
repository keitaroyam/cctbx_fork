===============
 phil overview
===============

Phil (Python-based hierarchical interchange language) is a
comprehensive system for the management of application parameters and,
to some degree, inputs. Many applications use command-line options as
a user interface (e.g. Python's optparse, a.k.a Optik). This approach
works well for small applications, but has it limitations for more
complex applications with a large set of parameters to direct the
underlying algorithms.

A simple Phil file as presented to the user may look like this::

  minimization.input {
    file_name = experiment.dat
    labels = x2 y2
  }
  minimization.output {
    model_file = final.mdl
    plot_file = None
  }
  minimization.parameters {
    method = *bfgs conjugate_gradient
    max_iterations = 10
  }

Phil is designed with a minimal syntax. An important goal is to
enable users to get started just by looking at defaults and examples,
without having to read documentation.

The Phil syntax has only two main elements, ``phil.definition`` (e.g.
``max_iterations = 10`` and ``phil.scope`` (e.g. ``minimization.input { }``).
To make this syntax as user-friendly as possible, strings
do not have to be quoted and, unlike Python, indentation is not
syntactically significant. E.g. this::

  minimization.input {
  file_name="experiment.dat"
  labels="x2" "y2"
  }

is equivalent to the corresponding definitions above.

Scopes can be nested recursively. The number of nesting levels is
limited only by Python's recursion limit (default 1000). To maximize
convenience, nested scopes can be defined in two equivalent ways.
For example::

  minimization {
    input {
    }
  }

is equivalent to::

  minimization.input {
  }

Beyond syntax
-------------

Phil is much more than just a parser for a very simple, user-friendly
syntax. Major Phil features are:

  - The concepts of `master files` and `user files`. The syntax
    for the two types of Phil files is identical, but the processed
    Phil files are used in different ways. I.e. the concepts exist
    only at the semantical level. The "look and feel" of the files is
    uniform.

  - Interpretation of command-line arguments as Phil definitions.

  - Merging of (multiple) Phil files and (multiple) Phil definitions
    derived from command-line arguments.

  - Automatic conversion of Phil files to pure Python objects
    which are completely independent of the Phil system. I.e.
    core algorithms using Phil-derived parameter objects do not
    actually have to depend on Phil.

  - The reverse conversion of (potentially modified) pure Python
    objects back to Phil files. This could also be viewed as a Phil
    pretty printer.

  - Shell-like variable substitution using $var and ${var} syntax.

  - ``include`` syntax to merge Phil files at the parser level,
    or to import Phil objects from other Python scripts.

Master files
------------

The master files are written by the software developer and include
"attributes" for each parameter, such as the type (integer,
floating-point, string, etc.) and support information for graphical
interfaces. For example::

  minimization.parameters
    .help = "Selection and tuning of minimization algorithm."
    .expert_level = 1
  {
    method = *bfgs conjugate_gradient
      .type = choice
    max_iterations = 10
      .type = int
      .input_size = 8
  }

The is the last part of the output of this command::

  libtbx.phil --show-some-attributes example.params

Run this command with ``--show-all-attributes`` to see the full set
of ``definition`` and ``scope`` attributes. This output tends to get
very long, but end-users don't have to be aware of this, and even
programmers only have to deal with the attributes they want to change.

User files
----------

User files are typically generated by the application. E.g.

  minimization.quick --show_defaults

will process its master file and show only the most
relevant parameters, classified by the software developer as
``.expert_level = 0`` (default). E.g. the ``minimization.parameters``
scope in the example above is not shown. The attributes are also
not shown. Therefore the output is much shorter compared to the
``libtbx.phil --show-some-attributes`` output above.

Command-line arguments + Phil
-----------------------------

In theory the user could save and edit the generated parameter files.
However, in most practical situations this is not necessary because of
two reasons.

Firstly, ``phenix.refine`` (and in the future other cctbx and Phenix
applications) inspects all input files and uses the information found
to fill in the blanks automatically. For example the unit cell is
copied from the input PDB file or, if this information is missing in
the PDB file, from a reflection file. This is not only convenient, but
also eliminates the possiblity of typing errors.

Secondly, command-line arguments that are not file names or options
prefixed with ``--`` (like ``--show_defaults`` above) are given to
Phil for examination. E.g., this is a possible command::

  phenix.refine peak.mtz model.pdb number_of_macro_cycles=10

Assume the first two arguments can be opened as files (the file names
may be specified in any order; ``phenix.refine`` detects the file types
automatically). Also assume that a file with the name
``number_of_macro_cycles=10`` does not exist. This argument will
therefore be interpreted with Phil.

Merging of Phil objects ("fetch")
---------------------------------

The Phil parser converts master files, user files and command line
arguments to uniform Phil objects which can be merged to generate a
combined set of "effective" parameters used in running the application.
We demonstrate this by way of a simple, self-contained Python script
with embedded Phil syntax::

  import iotbx.phil

  master_params = iotbx.phil.parse("""
    refinement.crystal_symmetry {
      unit_cell = None
        .type=unit_cell
      space_group = None
        .type=space_group
    }
    """)

  user_params = iotbx.phil.parse("""
    refinement.crystal_symmetry {
      unit_cell = 10 12 12 90 90 120
      space_group = None
    }
    """)

  command_line_params = iotbx.phil.parse(
    "refinement.crystal_symmetry.space_group=19")

  effective_params = master_params.fetch(
    sources=[user_params, command_line_params])
  effective_params.show()

The ``master_params`` define all available parameters including the
type information. The ``user_params`` override the default
``unit_cell`` assignment but leave the space group undefined. The
space group symbol is defined by the command line argument.
``effective_params.show()`` produces::

  refinement.crystal_symmetry {
    unit_cell = 10 12 12 90 90 120
    space_group = 19
  }

Having to type in fully qualified parameter names (e.g.
``refinement.crystal_symmetry.space_group``) can be very
inconvenient. Therefore Phil includes support for matching parameter
names of command-line arguments as substrings to the parameter names in
the master files::

  import libtbx.phil.command_line

  argument_interpreter = libtbx.phil.command_line.argument_interpreter(
    master_params=master_params,
    home_scope="refinement")

  command_line_params = argument_interpreter.process(
    arg="space_group=19")

This works even if the user writes just ``group=19`` or even
``e_gr=19``. The only requirement is that the substring leads to a
unique match in the master file. Otherwise Phil produces a helpful
error message. For example::

  argument_interpreter.process("u=19")

leads to::

  UserError: Ambiguous parameter definition: u = 19
  Best matches:
    refinement.crystal_symmetry.unit_cell
    refinement.crystal_symmetry.space_group

The user can cut-and-paste the desired parameter to edit the command
line for another trial to run the application.

Conversion of Phil objects to pure Python objects ("extract")
-------------------------------------------------------------

The Phil parser produces objects that preserve most information
generated in the parsing process, such as line numbers and parameter
attributes. While this information is very useful for pretty printing
(e.g. to archive effective parameters) and the automatic generation of
graphical user interfaces, it is only a burden in the context of core
numerical algorithms. Therefore Phil supports "extraction" of
light-weight pure Python objects from the Phil objects. Based on the
example above, this can be achieved with just one line::

  params = effective_params.extract()

We can now use the extracted objects in the context of Python::

  print params.refinement.crystal_symmetry.unit_cell
  print params.refinement.crystal_symmetry.space_group

Output::

  (10, 12, 12, 90, 90, 120)
  P 21 21 21

At first glance one may almost miss that something significant has
happend. However, we started out with "space_group=19" and now we see
``P 21 21 21`` in the output. This is because the ``space_group``
parameter was defined to be of ``.type=space_group`` in the master
file. Associated with each type are converters to and from corresponding
Python objects. In this case, the ``space_group`` converter produces
a Python object of type::

  print repr(params.refinement.crystal_symmetry.space_group)

Output::

  <cctbx.sgtbx.space_group_info instance at 0xb64edf6c>

This object cannot only show the space group symbol, but has
many other "methods". E.g. to print the list of symmetry operations
in "xyz" notation::

  for s in params.refinement.crystal_symmetry.space_group.group():
    print s

Output::

  x,y,z
  x+1/2,-y+1/2,-z
  -x,y+1/2,-z+1/2
  -x+1/2,-y,z+1/2

Conversion of Python objects to Phil objects ("format")
-------------------------------------------------------

Phil also supports the reverse conversion compared to the
previous section, from Python objects to Phil objects. For
example, to change the unit cell parameters::

  from cctbx import uctbx

  params.refinement.crystal_symmetry.unit_cell = uctbx.unit_cell(
    (10,12,15,90,90,90))
  modified_params = master_params.format(python_object=params)
  modified_params.show()

Output::

  refinement.crystal_symmetry {
    unit_cell = 10 12 15 90 90 90
    space_group = "P 21 21 21"
  }

We need to bring in the ``master_params`` again because all the meta
information was lost in the ``extract()`` step that produced
``params``. Again, a type-specific converter is used to produce
a string for each Python object. We started out with ``space_group=19``
but get back ``space_group = "P 21 21 21"`` because we chose to
make the converter work that way.

Extending Phil
--------------

The astude reader may have noticed that we used both ``libtbx.phil``
and ``iotbx.phil``. Why does Phil appear to have two homes?

The best way to think about Phil is to say "Phil is libtbx.phil." The
basic Phil objects storing the parsing results (``phil.definition`` and
``phil.scope``), the tokenizer, parser and the command line support are
implemented in the ``libtbx.phil`` module. ``iotbx.phil`` extends Phil
by adding two new types, ``unit_cell`` and ``space_group``. The
converters for these types can be found in ``$IOTBX_DIST/iotbx/phil.py``.
For example, this is the code for the unit cell converters::

  class unit_cell_converters:

    def __str__(self): return "unit_cell"

    def from_words(self, words, master):
      s = libtbx.phil.str_from_words(words=words)
      if (s is None): return None
      return uctbx.unit_cell(s)

    def as_words(self, python_object, master):
      if (python_object is None):
        return [tokenizer.word(value="None")]
      return [tokenizer.word(value="%.10g" % v)
        for v in python_object.parameters()]

Arbitrary new types can be added to Phil by defining similar
converters.  If desired, the built-in converters for the basic types
(``int``, ``float``, ``str``, etc.) defined in ``libtbx.phil`` can even
be replaced. All converters have to have ``__str__()``,
``from_words()`` and ``as_words()`` methods. More complex converters
may optionally have a non-trivial ``__init__()`` method (an example is
the ``choice_converters`` class in
``$LIBTBX_DIST/libtbx/phil/__init__.py``).

The ``iotbx.phil.parse()`` function used in the examples above is a
very small function which adds the ``unit_cell`` and ``space_group``
converters to Phil's default converter registry and then calls the main
``libtbx.phil.parse()`` function to do the actual work.
Following the example of ``iotbx.phil`` it should be straightforward
to add other domain-specific types to the Phil system.

Variable substitution
---------------------

Phil supports shell-like variable substitution using $var and ${var}
syntax. A few examples say more than many words::

  import libtbx.phil

  params = libtbx.phil.parse("""
    root_name = peak
    file_name = $root_name.mtz
    full_path = $HOME/$file_name
    related_file_name = ${root_name}_data.mtz
    message = "Reading $file_name"
    as_is = ' $file_name '
    """)
  params.fetch(source=params).show()

Output::

  root_name = peak
  file_name = "peak.mtz"
  full_path = "/net/cci/rwgk/peak.mtz"
  related_file_name = "peak_data.mtz"
  message = "Reading peak.mtz"
  as_is = ' $file_name '

Note that the variable substitution does not happen during parsing.
The output of ``params.show`` is identical to the input. In the
example above, variables are substituted by the ``fetch()`` method
that we introduced earlier to merge user files given a master file.

Phil odds and ends
------------------

Phil also supports merging of files at the parsing level. The syntax is
simply ``include file file_name``. ``include`` directives may appear inside
scopes to enable hierarchical building of master files without the need
to copy-and-paste large fragments explicitly. Duplication appears only
in automatically generated user files. I.e. the programmer is well
served because a system of master files can be kept free of large-scale
redundancies that are difficult to maintain. At the same time the end
user is well served because the indirections are resolved automatically
and all parameters are presented in one uniform view.

Variable substitution and include directives smell almost like
programming. However, there is a line that Phil is never meant to
cross: flow control is not a part of the syntax. It is hard to imagine
that a fully featured programming language could be syntactically
simpler than Python. For example, there are good reasons why Python
string literals have to be quoted. Otherwise Python scripts would be
full of ``$`` signs because some method is needed to distinguish
strings from variable names. On the other hand, having to quote space
group symbols in parameter files is a nusiance. In the future we may
extend Phil as an interchange format for data other than parameters
but for our programming needs we feel extremely well served by Python.

Rules for .multiple=True phil objects
-------------------------------------

definition with .multiple=True
  .extract() returns a list of definition values.

scope with .multiple=True
  .extract() returns a list of definition values or scope_extract
  objects (which inherit from Python's built-in list).

With .optional=True (default if not specified explicitly):
  The master definition is NEVER included in the extract result list.
  It does not matter how often it is repeated in the user file.

With .optional=False:
  The master definition is ALWAYS included in the extract result list.
  It is always the first entry in the list, no matter how often
  it is repeated in the user file.

This set of rules is designed to produce easily predictable results
in situations where multiple parameter files are merged (with
master.fetch()), including complete copies of the master file.

.multiple=True examples
-----------------------

In a master file, the first occurrence of a multiple scope is a
"template", all following occurrences are defaults, e.g.::

      group
        .multiple = True
      {
        selection = None
          .type = str
        f_prime = 0
          .type = float
        f_double_prime = 0
          .type = float
        refine = *f_prime *f_double_prime
          .optional = True
          .type = choice(multi=True)
      }

This template will not get extracted, even though it contains defines
that are not None.

The following example shows how to define defaults for multiple scopes::

  mtz_labels
    .multiple=True
  {
    map_type = None
      .type=str
    amplitudes = None
      .type=str
    phases = None
      .type=str
  }
  mtz_labels {
    map_type = 2m*Fobs-D*Fmodel
    amplitudes = 2FOFCWT
    phases = PH2FOFCWT
  }
  mtz_labels {
    map_type = m*Fobs-D*Fmodel
    amplitudes = FOFCWT
    phases = PHFOFCWT
  }

.extract() will return a list with two elements.

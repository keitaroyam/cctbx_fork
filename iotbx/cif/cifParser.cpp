/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g
 *     -                            On : 2010-05-25 14:41:31
 *     -                for the parser : cifParserParser *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "cifParser.h"
/* ----------------------------------------- */

/** CIF Version 1.1 Working specification grammar

Translated from the grammar defined at

http://www.iucr.org/resources/cif/spec/version1.1/cifsyntax#bnf

A compiled version of the parser, with C language target, but contains
C++ code in the actions, therefore the output files must be renamed to *.cpp

Richard Gildea
April 2010
*/




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define         CTX     ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef  SCOPE_TYPE
#undef  SCOPE_STACK
#undef  SCOPE_TOP
#define SCOPE_TYPE(scope)   pcifParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pcifParser_##scope##Stack
#define SCOPE_TOP(scope)    ctx->pcifParser_##scope##Top
#define SCOPE_SIZE(scope)               ctx->pcifParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)        (ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef      PARSER
#undef      RECOGNIZER
#undef      HAVEPARSEDRULE
#undef          MEMOIZE
#undef      INPUT
#undef      STRSTREAM
#undef      HASEXCEPTION
#undef      EXCEPTION
#undef      MATCHT
#undef      MATCHANYT
#undef      FOLLOWSTACK
#undef      FOLLOWPUSH
#undef      FOLLOWPOP
#undef      PRECOVER
#undef      PREPORTERROR
#undef      LA
#undef      LT
#undef      CONSTRUCTEX
#undef      CONSUME
#undef      MARK
#undef      REWIND
#undef      REWINDLAST
#undef      PERRORRECOVERY
#undef      HASFAILED
#undef      FAILEDFLAG
#undef      RECOVERFROMMISMATCHEDSET
#undef      RECOVERFROMMISMATCHEDELEMENT
#undef          INDEX
#undef      ADAPTOR
#undef          SEEK
#undef      RULEMEMO
#undef          DBG

#define     PARSER                                                      ctx->pParser
#define     RECOGNIZER                                          PARSER->rec
#define         PSRSTATE                                                RECOGNIZER->state
#define     HAVEPARSEDRULE(r)                           RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define         MEMOIZE(ri,si)                                  RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define     INPUT                                                       PARSER->tstream
#define     STRSTREAM                                           INPUT
#define         ISTREAM                                                 INPUT->istream
#define         INDEX()                                                 ISTREAM->index(INPUT->istream)
#define     HASEXCEPTION()                                      (PSRSTATE->error == ANTLR3_TRUE)
#define     EXCEPTION                                           PSRSTATE->exception
#define     MATCHT(t, fs)                                       RECOGNIZER->match(RECOGNIZER, t, fs)
#define     MATCHANYT()                                         RECOGNIZER->matchAny(RECOGNIZER)
#define     FOLLOWSTACK                                     PSRSTATE->following
#define     FOLLOWPUSH(x)                                       FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define     FOLLOWPOP()                                         FOLLOWSTACK->pop(FOLLOWSTACK)
#define     PRECOVER()                                          RECOGNIZER->recover(RECOGNIZER)
#define     PREPORTERROR()                                      RECOGNIZER->reportError(RECOGNIZER)
#define     LA(n)                                                       INPUT->istream->_LA(ISTREAM, n)
#define     LT(n)                                                       INPUT->_LT(INPUT, n)
#define     CONSTRUCTEX()                                       RECOGNIZER->exConstruct(RECOGNIZER)
#define     CONSUME()                                           ISTREAM->consume(ISTREAM)
#define     MARK()                                                      ISTREAM->mark(ISTREAM)
#define     REWIND(m)                                           ISTREAM->rewind(ISTREAM, m)
#define     REWINDLAST()                                        ISTREAM->rewindLast(ISTREAM)
#define         SEEK(n)                                                 ISTREAM->seek(ISTREAM, n)
#define     PERRORRECOVERY                                      PSRSTATE->errorRecovery
#define     FAILEDFLAG                                          PSRSTATE->failed
#define     HASFAILED()                                         (FAILEDFLAG == ANTLR3_TRUE)
#define     BACKTRACKING                                        PSRSTATE->backtracking
#define     RECOVERFROMMISMATCHEDSET(s)         RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define     RECOVERFROMMISMATCHEDELEMENT(e)     RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define         RULEMEMO                                                PSRSTATE->ruleMemo
#define         DBG                                                             RECOGNIZER->debugger

#define         TOKTEXT(tok, txt)                               tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define     UP      ANTLR3_TOKEN_UP
#define     DOWN    ANTLR3_TOKEN_DOWN
#define     EOR     ANTLR3_TOKEN_EOR
#define     INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a cifParser_parse scope set
 */
static pcifParser_parse_SCOPE   pcifParser_parsePush(pcifParser ctx);
static void ANTLR3_CDECL parseFree(pcifParser_parse_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL parseFree(pcifParser_parse_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a cifParser parse scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pcifParser_parseTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pcifParser_parse_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pcifParser_parse_SCOPE
pcifParser_parsePush(pcifParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pcifParser_parse_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pcifParser_parseStack->size(ctx->pcifParser_parseStack) > ctx->pcifParser_parseStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pcifParser_parse_SCOPE)ctx->pcifParser_parseStack->get(ctx->pcifParser_parseStack, ctx->pcifParser_parseStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pcifParser_parse_SCOPE) ANTLR3_MALLOC(sizeof(cifParser_parse_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pcifParser_parseStack->push(ctx->pcifParser_parseStack, newAttributes, (void (*)(void *))parseFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pcifParser_parseStack_limit++;

        /* Return value is the pointer to the new entry, which may be used locally
         * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a cifParser_data_items scope set
 */
static pcifParser_data_items_SCOPE   pcifParser_data_itemsPush(pcifParser ctx);
static void ANTLR3_CDECL data_itemsFree(pcifParser_data_items_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL data_itemsFree(pcifParser_data_items_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a cifParser data_items scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pcifParser_data_itemsTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pcifParser_data_items_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pcifParser_data_items_SCOPE
pcifParser_data_itemsPush(pcifParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pcifParser_data_items_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pcifParser_data_itemsStack->size(ctx->pcifParser_data_itemsStack) > ctx->pcifParser_data_itemsStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pcifParser_data_items_SCOPE)ctx->pcifParser_data_itemsStack->get(ctx->pcifParser_data_itemsStack, ctx->pcifParser_data_itemsStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pcifParser_data_items_SCOPE) ANTLR3_MALLOC(sizeof(cifParser_data_items_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pcifParser_data_itemsStack->push(ctx->pcifParser_data_itemsStack, newAttributes, (void (*)(void *))data_itemsFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pcifParser_data_itemsStack_limit++;

        /* Return value is the pointer to the new entry, which may be used locally
         * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   cifParserTokenNames[33+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "COMMENTS",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "SAVE_FRAME_HEADING",
        (pANTLR3_UINT8) "SAVE",
        (pANTLR3_UINT8) "TAG",
        (pANTLR3_UINT8) "DATA_BLOCK_HEADING",
        (pANTLR3_UINT8) "LOOP_",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "EXPONENT",
        (pANTLR3_UINT8) "CHAR_STRING",
        (pANTLR3_UINT8) "SEMI_COLON_TEXT_FIELD",
        (pANTLR3_UINT8) "EOL",
        (pANTLR3_UINT8) "DOUBLE_QUOTE",
        (pANTLR3_UINT8) "SINGLE_QUOTE",
        (pANTLR3_UINT8) "ORDINARY_CHAR",
        (pANTLR3_UINT8) "NON_BLANK_CHAR_",
        (pANTLR3_UINT8) "TEXT_LEAD_CHAR",
        (pANTLR3_UINT8) "ANY_PRINT_CHAR",
        (pANTLR3_UINT8) "DATA_",
        (pANTLR3_UINT8) "SAVE_",
        (pANTLR3_UINT8) "GLOBAL_",
        (pANTLR3_UINT8) "STOP_",
        (pANTLR3_UINT8) "VERSION",
        (pANTLR3_UINT8) "NON_BLANK_CHAR",
        (pANTLR3_UINT8) "SINGLE_QUOTED_STRING",
        (pANTLR3_UINT8) "DOUBLE_QUOTED_STRING",
        (pANTLR3_UINT8) "UNQUOTED_STRING",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'?'",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'"
       };


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pcifParser_parseStack
 */
void
pcifParser_parsePop(pcifParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
        // If the user supplied the scope entries with a free function,then call it first
        //
    if  (SCOPE_TOP(parse)->free != NULL)
        {
        SCOPE_TOP(parse)->free(SCOPE_TOP(parse));
        }

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pcifParser_parseStack_limit--;
    SCOPE_TOP(parse) = (pcifParser_parse_SCOPE)(ctx->pcifParser_parseStack->get(ctx->pcifParser_parseStack, ctx->pcifParser_parseStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pcifParser_data_itemsStack
 */
void
pcifParser_data_itemsPop(pcifParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
        // If the user supplied the scope entries with a free function,then call it first
        //
    if  (SCOPE_TOP(data_items)->free != NULL)
        {
        SCOPE_TOP(data_items)->free(SCOPE_TOP(data_items));
        }

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pcifParser_data_itemsStack_limit--;
    SCOPE_TOP(data_items) = (pcifParser_data_items_SCOPE)(ctx->pcifParser_data_itemsStack->get(ctx->pcifParser_data_itemsStack, ctx->pcifParser_data_itemsStack_limit - 1));
}


// Forward declare the locally static matching functions we have generated.
//
static void     parse    (pcifParser ctx, boost::python::object & builder_);
static void     cif    (pcifParser ctx);
static void     loop_body    (pcifParser ctx);
static void     save_frame    (pcifParser ctx);
static void     data_items    (pcifParser ctx);
static void     data_block    (pcifParser ctx);
static cifParser_loop_header_return     loop_header    (pcifParser ctx);
static void     inapplicable    (pcifParser ctx);
static void     unknown    (pcifParser ctx);
static cifParser_value_return   value    (pcifParser ctx);
static void     unsigned_integer    (pcifParser ctx);
static void     integer    (pcifParser ctx);
static void     float_    (pcifParser ctx);
static void     number    (pcifParser ctx);
static void     numeric    (pcifParser ctx);
static void     char_string    (pcifParser ctx);
static void     text_field    (pcifParser ctx);
static void     cifParserFree(pcifParser ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static  void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
        return fileName;
}
/** \brief Create a new cifParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcifParser
cifParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
        // See if we can create a new parser with the standard constructor
        //
        return cifParserNewSSD(instream, NULL);
}

/** \brief Create a new cifParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcifParser
cifParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pcifParser ctx;         /* Context structure we will build and return   */

    ctx = (pcifParser) ANTLR3_CALLOC(1, sizeof(cifParser));

    if  (ctx == NULL)
    {
                // Failed to allocate memory for parser context
                //
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in cifParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser            = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our cifParser interface
     */
    ctx->parse  = parse;
    ctx->cif    = cif;
    ctx->loop_body      = loop_body;
    ctx->save_frame     = save_frame;
    ctx->data_items     = data_items;
    ctx->data_block     = data_block;
    ctx->loop_header    = loop_header;
    ctx->inapplicable   = inapplicable;
    ctx->unknown        = unknown;
    ctx->value  = value;
    ctx->unsigned_integer       = unsigned_integer;
    ctx->integer        = integer;
    ctx->float_ = float_;
    ctx->number = number;
    ctx->numeric        = numeric;
    ctx->char_string    = char_string;
    ctx->text_field     = text_field;
    ctx->free                   = cifParserFree;
    ctx->getGrammarFileName     = getGrammarFileName;

    /* Install the scope pushing methods.
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pcifParser_parsePush     = pcifParser_parsePush;
    ctx->pcifParser_parseStack    = antlr3StackNew(0);
    ctx->pcifParser_parseStack_limit    = 0;
    ctx->pcifParser_parseTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pcifParser_data_itemsPush     = pcifParser_data_itemsPush;
    ctx->pcifParser_data_itemsStack    = antlr3StackNew(0);
    ctx->pcifParser_data_itemsStack_limit    = 0;
    ctx->pcifParser_data_itemsTop      = NULL;






    /* Install the token table
     */
    PSRSTATE->tokenNames   = cifParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 cifParserFree(pcifParser ctx)
 {
    /* Free any scope memory
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pcifParser_parseStack->free(ctx->pcifParser_parseStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pcifParser_data_itemsStack->free(ctx->pcifParser_data_itemsStack);



        // Free this parser
        //
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return cifParserTokenNames;
}


    std::string to_std_string(pANTLR3_STRING text) {
        return std::string((const char*)text->chars);
    }


/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_cif_in_parse58  */
static  ANTLR3_BITWORD FOLLOW_cif_in_parse58_bits[]     = { ANTLR3_UINT64_LIT(0x0000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_cif_in_parse58        = { FOLLOW_cif_in_parse58_bits, 1       };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_parse60  */
static  ANTLR3_BITWORD FOLLOW_EOF_in_parse60_bits[]     = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_parse60        = { FOLLOW_EOF_in_parse60_bits, 1       };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMENTS_in_cif73  */
static  ANTLR3_BITWORD FOLLOW_COMMENTS_in_cif73_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMENTS_in_cif73     = { FOLLOW_COMMENTS_in_cif73_bits, 1    };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHITESPACE_in_cif78  */
static  ANTLR3_BITWORD FOLLOW_WHITESPACE_in_cif78_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_WHITESPACE_in_cif78   = { FOLLOW_WHITESPACE_in_cif78_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_data_block_in_cif84  */
static  ANTLR3_BITWORD FOLLOW_data_block_in_cif84_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_data_block_in_cif84   = { FOLLOW_data_block_in_cif84_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHITESPACE_in_cif88  */
static  ANTLR3_BITWORD FOLLOW_WHITESPACE_in_cif88_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_WHITESPACE_in_cif88   = { FOLLOW_WHITESPACE_in_cif88_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_data_block_in_cif91  */
static  ANTLR3_BITWORD FOLLOW_data_block_in_cif91_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_data_block_in_cif91   = { FOLLOW_data_block_in_cif91_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHITESPACE_in_cif97  */
static  ANTLR3_BITWORD FOLLOW_WHITESPACE_in_cif97_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WHITESPACE_in_cif97   = { FOLLOW_WHITESPACE_in_cif97_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_loop_body115  */
static  ANTLR3_BITWORD FOLLOW_value_in_loop_body115_bits[]      = { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_loop_body115 = { FOLLOW_value_in_loop_body115_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHITESPACE_in_loop_body128  */
static  ANTLR3_BITWORD FOLLOW_WHITESPACE_in_loop_body128_bits[] = { ANTLR3_UINT64_LIT(0x0000000780006820) };
static  ANTLR3_BITSET_LIST FOLLOW_WHITESPACE_in_loop_body128    = { FOLLOW_WHITESPACE_in_loop_body128_bits, 1   };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_loop_body142  */
static  ANTLR3_BITWORD FOLLOW_value_in_loop_body142_bits[]      = { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_loop_body142 = { FOLLOW_value_in_loop_body142_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SAVE_FRAME_HEADING_in_save_frame166  */
static  ANTLR3_BITWORD FOLLOW_SAVE_FRAME_HEADING_in_save_frame166_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_SAVE_FRAME_HEADING_in_save_frame166   = { FOLLOW_SAVE_FRAME_HEADING_in_save_frame166_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHITESPACE_in_save_frame170  */
static  ANTLR3_BITWORD FOLLOW_WHITESPACE_in_save_frame170_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000520) };
static  ANTLR3_BITSET_LIST FOLLOW_WHITESPACE_in_save_frame170   = { FOLLOW_WHITESPACE_in_save_frame170_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_data_items_in_save_frame173  */
static  ANTLR3_BITWORD FOLLOW_data_items_in_save_frame173_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_data_items_in_save_frame173   = { FOLLOW_data_items_in_save_frame173_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHITESPACE_in_save_frame178  */
static  ANTLR3_BITWORD FOLLOW_WHITESPACE_in_save_frame178_bits[]        = { ANTLR3_UINT64_LIT(0x00000000000000A0) };
static  ANTLR3_BITSET_LIST FOLLOW_WHITESPACE_in_save_frame178   = { FOLLOW_WHITESPACE_in_save_frame178_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SAVE_in_save_frame181  */
static  ANTLR3_BITWORD FOLLOW_SAVE_in_save_frame181_bits[]      = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SAVE_in_save_frame181 = { FOLLOW_SAVE_in_save_frame181_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TAG_in_data_items205  */
static  ANTLR3_BITWORD FOLLOW_TAG_in_data_items205_bits[]       = { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_TAG_in_data_items205  = { FOLLOW_TAG_in_data_items205_bits, 1 };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHITESPACE_in_data_items207  */
static  ANTLR3_BITWORD FOLLOW_WHITESPACE_in_data_items207_bits[]        = { ANTLR3_UINT64_LIT(0x0000000780006800) };
static  ANTLR3_BITSET_LIST FOLLOW_WHITESPACE_in_data_items207   = { FOLLOW_WHITESPACE_in_data_items207_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_data_items209  */
static  ANTLR3_BITWORD FOLLOW_value_in_data_items209_bits[]     = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_data_items209        = { FOLLOW_value_in_data_items209_bits, 1       };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_loop_header_in_data_items222  */
static  ANTLR3_BITWORD FOLLOW_loop_header_in_data_items222_bits[]       = { ANTLR3_UINT64_LIT(0x0000000780006820) };
static  ANTLR3_BITSET_LIST FOLLOW_loop_header_in_data_items222  = { FOLLOW_loop_header_in_data_items222_bits, 1 };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHITESPACE_in_data_items224  */
static  ANTLR3_BITWORD FOLLOW_WHITESPACE_in_data_items224_bits[]        = { ANTLR3_UINT64_LIT(0x0000000780006820) };
static  ANTLR3_BITSET_LIST FOLLOW_WHITESPACE_in_data_items224   = { FOLLOW_WHITESPACE_in_data_items224_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_loop_body_in_data_items227  */
static  ANTLR3_BITWORD FOLLOW_loop_body_in_data_items227_bits[] = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_loop_body_in_data_items227    = { FOLLOW_loop_body_in_data_items227_bits, 1   };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DATA_BLOCK_HEADING_in_data_block240  */
static  ANTLR3_BITWORD FOLLOW_DATA_BLOCK_HEADING_in_data_block240_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_DATA_BLOCK_HEADING_in_data_block240   = { FOLLOW_DATA_BLOCK_HEADING_in_data_block240_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHITESPACE_in_data_block253  */
static  ANTLR3_BITWORD FOLLOW_WHITESPACE_in_data_block253_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000560) };
static  ANTLR3_BITSET_LIST FOLLOW_WHITESPACE_in_data_block253   = { FOLLOW_WHITESPACE_in_data_block253_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_data_items_in_data_block258  */
static  ANTLR3_BITWORD FOLLOW_data_items_in_data_block258_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_data_items_in_data_block258   = { FOLLOW_data_items_in_data_block258_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_save_frame_in_data_block262  */
static  ANTLR3_BITWORD FOLLOW_save_frame_in_data_block262_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_save_frame_in_data_block262   = { FOLLOW_save_frame_in_data_block262_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOOP__in_loop_header278  */
static  ANTLR3_BITWORD FOLLOW_LOOP__in_loop_header278_bits[]    = { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_LOOP__in_loop_header278       = { FOLLOW_LOOP__in_loop_header278_bits, 1      };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHITESPACE_in_loop_header282  */
static  ANTLR3_BITWORD FOLLOW_WHITESPACE_in_loop_header282_bits[]       = { ANTLR3_UINT64_LIT(0x0000000000000120) };
static  ANTLR3_BITSET_LIST FOLLOW_WHITESPACE_in_loop_header282  = { FOLLOW_WHITESPACE_in_loop_header282_bits, 1 };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TAG_in_loop_header285  */
static  ANTLR3_BITWORD FOLLOW_TAG_in_loop_header285_bits[]      = { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_TAG_in_loop_header285 = { FOLLOW_TAG_in_loop_header285_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHITESPACE_in_loop_header290  */
static  ANTLR3_BITWORD FOLLOW_WHITESPACE_in_loop_header290_bits[]       = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WHITESPACE_in_loop_header290  = { FOLLOW_WHITESPACE_in_loop_header290_bits, 1 };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_inapplicable304  */
static  ANTLR3_BITWORD FOLLOW_31_in_inapplicable304_bits[]      = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_inapplicable304 = { FOLLOW_31_in_inapplicable304_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_unknown313  */
static  ANTLR3_BITWORD FOLLOW_32_in_unknown313_bits[]   = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_unknown313      = { FOLLOW_32_in_unknown313_bits, 1     };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_inapplicable_in_value323  */
static  ANTLR3_BITWORD FOLLOW_inapplicable_in_value323_bits[]   = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_inapplicable_in_value323      = { FOLLOW_inapplicable_in_value323_bits, 1     };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unknown_in_value327  */
static  ANTLR3_BITWORD FOLLOW_unknown_in_value327_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unknown_in_value327   = { FOLLOW_unknown_in_value327_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_value331  */
static  ANTLR3_BITWORD FOLLOW_33_in_value331_bits[]     = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_value331        = { FOLLOW_33_in_value331_bits, 1       };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_char_string_in_value335  */
static  ANTLR3_BITWORD FOLLOW_char_string_in_value335_bits[]    = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_char_string_in_value335       = { FOLLOW_char_string_in_value335_bits, 1      };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeric_in_value340  */
static  ANTLR3_BITWORD FOLLOW_numeric_in_value340_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numeric_in_value340   = { FOLLOW_numeric_in_value340_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_field_in_value343  */
static  ANTLR3_BITWORD FOLLOW_text_field_in_value343_bits[]     = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_text_field_in_value343        = { FOLLOW_text_field_in_value343_bits, 1       };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_unsigned_integer362  */
static  ANTLR3_BITWORD FOLLOW_DIGIT_in_unsigned_integer362_bits[]       = { ANTLR3_UINT64_LIT(0x0000000000000802) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_unsigned_integer362  = { FOLLOW_DIGIT_in_unsigned_integer362_bits, 1 };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_integer374  */
static  ANTLR3_BITWORD FOLLOW_set_in_integer374_bits[]  = { ANTLR3_UINT64_LIT(0x0000000600000800) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_integer374     = { FOLLOW_set_in_integer374_bits, 1    };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unsigned_integer_in_integer385  */
static  ANTLR3_BITWORD FOLLOW_unsigned_integer_in_integer385_bits[]     = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unsigned_integer_in_integer385        = { FOLLOW_unsigned_integer_in_integer385_bits, 1       };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_float_396  */
static  ANTLR3_BITWORD FOLLOW_integer_in_float_396_bits[]       = { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_float_396  = { FOLLOW_integer_in_float_396_bits, 1 };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXPONENT_in_float_398  */
static  ANTLR3_BITWORD FOLLOW_EXPONENT_in_float_398_bits[]      = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EXPONENT_in_float_398 = { FOLLOW_EXPONENT_in_float_398_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_float_404  */
static  ANTLR3_BITWORD FOLLOW_set_in_float_404_bits[]   = { ANTLR3_UINT64_LIT(0x0000000080000800) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_float_404      = { FOLLOW_set_in_float_404_bits, 1     };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_float_418  */
static  ANTLR3_BITWORD FOLLOW_DIGIT_in_float_418_bits[] = { ANTLR3_UINT64_LIT(0x0000000080000800) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_float_418    = { FOLLOW_DIGIT_in_float_418_bits, 1   };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_float_422  */
static  ANTLR3_BITWORD FOLLOW_31_in_float_422_bits[]    = { ANTLR3_UINT64_LIT(0x0000000600000800) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_float_422       = { FOLLOW_31_in_float_422_bits, 1      };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unsigned_integer_in_float_424  */
static  ANTLR3_BITWORD FOLLOW_unsigned_integer_in_float_424_bits[]      = { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_unsigned_integer_in_float_424 = { FOLLOW_unsigned_integer_in_float_424_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_float_430  */
static  ANTLR3_BITWORD FOLLOW_DIGIT_in_float_430_bits[] = { ANTLR3_UINT64_LIT(0x0000000080000800) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_float_430    = { FOLLOW_DIGIT_in_float_430_bits, 1   };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_float_434  */
static  ANTLR3_BITWORD FOLLOW_31_in_float_434_bits[]    = { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_float_434       = { FOLLOW_31_in_float_434_bits, 1      };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXPONENT_in_float_439  */
static  ANTLR3_BITWORD FOLLOW_EXPONENT_in_float_439_bits[]      = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EXPONENT_in_float_439 = { FOLLOW_EXPONENT_in_float_439_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_number451  */
static  ANTLR3_BITWORD FOLLOW_integer_in_number451_bits[]       = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_number451  = { FOLLOW_integer_in_number451_bits, 1 };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_float__in_number455  */
static  ANTLR3_BITWORD FOLLOW_float__in_number455_bits[]        = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_float__in_number455   = { FOLLOW_float__in_number455_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_number_in_numeric464  */
static  ANTLR3_BITWORD FOLLOW_number_in_numeric464_bits[]       = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_number_in_numeric464  = { FOLLOW_number_in_numeric464_bits, 1 };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_number_in_numeric470  */
static  ANTLR3_BITWORD FOLLOW_number_in_numeric470_bits[]       = { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_number_in_numeric470  = { FOLLOW_number_in_numeric470_bits, 1 };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_numeric472  */
static  ANTLR3_BITWORD FOLLOW_35_in_numeric472_bits[]   = { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_numeric472      = { FOLLOW_35_in_numeric472_bits, 1     };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_numeric475  */
static  ANTLR3_BITWORD FOLLOW_DIGIT_in_numeric475_bits[]        = { ANTLR3_UINT64_LIT(0x0000001000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_numeric475   = { FOLLOW_DIGIT_in_numeric475_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_numeric479  */
static  ANTLR3_BITWORD FOLLOW_36_in_numeric479_bits[]   = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_numeric479      = { FOLLOW_36_in_numeric479_bits, 1     };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHAR_STRING_in_char_string491  */
static  ANTLR3_BITWORD FOLLOW_CHAR_STRING_in_char_string491_bits[]      = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHAR_STRING_in_char_string491 = { FOLLOW_CHAR_STRING_in_char_string491_bits, 1        };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_COLON_TEXT_FIELD_in_text_field501  */
static  ANTLR3_BITWORD FOLLOW_SEMI_COLON_TEXT_FIELD_in_text_field501_bits[]     = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_COLON_TEXT_FIELD_in_text_field501        = { FOLLOW_SEMI_COLON_TEXT_FIELD_in_text_field501_bits, 1       };



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 66:8: ( ( WHITESPACE )+ v2= value )*
 */
static const ANTLR3_INT32 dfa8_eot[5] =
    {
        -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa8_eof[5] =
    {
        2, 2, -1, -1, -1
    };
static const ANTLR3_INT32 dfa8_min[5] =
    {
        5, 5, -1, 5, -1
    };
static const ANTLR3_INT32 dfa8_max[5] =
    {
        9, 34, -1, 34, -1
    };
static const ANTLR3_INT32 dfa8_accept[5] =
    {
        -1, -1, 2, -1, 1
    };
static const ANTLR3_INT32 dfa8_special[5] =
    {
        -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa8_T_empty        NULL

static const ANTLR3_INT32 dfa8_T0[] =
    {
        3, 2, 2, 2, 2, 2, 4, -1, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa8_T1[] =
    {
        1, -1, -1, -1, 2
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa8_transitions[] =
{
    dfa8_T1, dfa8_T0, dfa8_T_empty, dfa8_T0, dfa8_T_empty
};


/* Declare tracking structure for Cyclic DFA 8
 */
static
ANTLR3_CYCLIC_DFA cdfa8
    =   {
            8,              /* Decision number of this dfa          */
            /* Which decision this represents:   */
            (const pANTLR3_UCHAR)"()* loopback of 66:8: ( ( WHITESPACE )+ v2= value )*",
            (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,        /* Default special state transition function    */
            antlr3dfaspecialTransition,         /* DFA specialTransition is currently just a default function in the runtime */
            antlr3dfapredict,                   /* DFA simulator function is in the runtime */
            dfa8_eot,       /* EOT table                            */
            dfa8_eof,       /* EOF table                            */
            dfa8_min,       /* Minimum tokens for each state    */
            dfa8_max,       /* Maximum tokens for each state    */
            dfa8_accept,        /* Accept table                     */
            dfa8_special,       /* Special transition states        */
            dfa8_transitions    /* Table of transition tables       */

        };
/* End of Cyclic DFA 8
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()+ loopback of 73:23: ( ( WHITESPACE )+ data_items )+
 */
static const ANTLR3_INT32 dfa10_eot[4] =
    {
        -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa10_eof[4] =
    {
        -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa10_min[4] =
    {
        5, 5, -1, -1
    };
static const ANTLR3_INT32 dfa10_max[4] =
    {
        5, 10, -1, -1
    };
static const ANTLR3_INT32 dfa10_accept[4] =
    {
        -1, -1, 1, 2
    };
static const ANTLR3_INT32 dfa10_special[4] =
    {
        -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa10_T_empty       NULL

static const ANTLR3_INT32 dfa10_T0[] =
    {
        1
    };static const ANTLR3_INT32 dfa10_T1[] =
    {
        1, -1, 3, 2, -1, 2
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa10_transitions[] =
{
    dfa10_T0, dfa10_T1, dfa10_T_empty, dfa10_T_empty
};


/* Declare tracking structure for Cyclic DFA 10
 */
static
ANTLR3_CYCLIC_DFA cdfa10
    =   {
            10,             /* Decision number of this dfa          */
            /* Which decision this represents:   */
            (const pANTLR3_UCHAR)"()+ loopback of 73:23: ( ( WHITESPACE )+ data_items )+",
            (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,        /* Default special state transition function    */
            antlr3dfaspecialTransition,         /* DFA specialTransition is currently just a default function in the runtime */
            antlr3dfapredict,                   /* DFA simulator function is in the runtime */
            dfa10_eot,      /* EOT table                            */
            dfa10_eof,      /* EOF table                            */
            dfa10_min,      /* Minimum tokens for each state    */
            dfa10_max,      /* Maximum tokens for each state    */
            dfa10_accept,       /* Accept table                     */
            dfa10_special,      /* Special transition states        */
            dfa10_transitions   /* Table of transition tables       */

        };
/* End of Cyclic DFA 10
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 100:8: ( ( WHITESPACE )+ ( data_items | save_frame ) )*
 */
static const ANTLR3_INT32 dfa16_eot[5] =
    {
        -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa16_eof[5] =
    {
        2, 2, -1, -1, -1
    };
static const ANTLR3_INT32 dfa16_min[5] =
    {
        5, 5, -1, 5, -1
    };
static const ANTLR3_INT32 dfa16_max[5] =
    {
        9, 10, -1, 10, -1
    };
static const ANTLR3_INT32 dfa16_accept[5] =
    {
        -1, -1, 2, -1, 1
    };
static const ANTLR3_INT32 dfa16_special[5] =
    {
        -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa16_T_empty       NULL

static const ANTLR3_INT32 dfa16_T0[] =
    {
        3, 4, -1, 4, 2, 4
    };static const ANTLR3_INT32 dfa16_T1[] =
    {
        1, -1, -1, -1, 2
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa16_transitions[] =
{
    dfa16_T1, dfa16_T0, dfa16_T_empty, dfa16_T0, dfa16_T_empty
};


/* Declare tracking structure for Cyclic DFA 16
 */
static
ANTLR3_CYCLIC_DFA cdfa16
    =   {
            16,             /* Decision number of this dfa          */
            /* Which decision this represents:   */
            (const pANTLR3_UCHAR)"()* loopback of 100:8: ( ( WHITESPACE )+ ( data_items | save_frame ) )*",
            (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,        /* Default special state transition function    */
            antlr3dfaspecialTransition,         /* DFA specialTransition is currently just a default function in the runtime */
            antlr3dfapredict,                   /* DFA simulator function is in the runtime */
            dfa16_eot,      /* EOT table                            */
            dfa16_eof,      /* EOF table                            */
            dfa16_min,      /* Minimum tokens for each state    */
            dfa16_max,      /* Maximum tokens for each state    */
            dfa16_accept,       /* Accept table                     */
            dfa16_special,      /* Special transition states        */
            dfa16_transitions   /* Table of transition tables       */

        };
/* End of Cyclic DFA 16
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()+ loopback of 104:10: ( ( WHITESPACE )+ TAG )+
 */
static const ANTLR3_INT32 dfa18_eot[5] =
    {
        -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa18_eof[5] =
    {
        -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa18_min[5] =
    {
        5, 5, 5, -1, -1
    };
static const ANTLR3_INT32 dfa18_max[5] =
    {
        5, 34, 34, -1, -1
    };
static const ANTLR3_INT32 dfa18_accept[5] =
    {
        -1, -1, -1, 2, 1
    };
static const ANTLR3_INT32 dfa18_special[5] =
    {
        -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa18_T_empty       NULL

static const ANTLR3_INT32 dfa18_T0[] =
    {
        2, -1, -1, 4, -1, -1, 3, -1, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T1[] =
    {
        1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa18_transitions[] =
{
    dfa18_T1, dfa18_T0, dfa18_T0, dfa18_T_empty, dfa18_T_empty
};


/* Declare tracking structure for Cyclic DFA 18
 */
static
ANTLR3_CYCLIC_DFA cdfa18
    =   {
            18,             /* Decision number of this dfa          */
            /* Which decision this represents:   */
            (const pANTLR3_UCHAR)"()+ loopback of 104:10: ( ( WHITESPACE )+ TAG )+",
            (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,        /* Default special state transition function    */
            antlr3dfaspecialTransition,         /* DFA specialTransition is currently just a default function in the runtime */
            antlr3dfapredict,                   /* DFA simulator function is in the runtime */
            dfa18_eot,      /* EOT table                            */
            dfa18_eof,      /* EOF table                            */
            dfa18_min,      /* Minimum tokens for each state    */
            dfa18_max,      /* Maximum tokens for each state    */
            dfa18_accept,       /* Accept table                     */
            dfa18_special,      /* Special transition states        */
            dfa18_transitions   /* Table of transition tables       */

        };
/* End of Cyclic DFA 18
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    126:1: float_ : ( integer EXPONENT | ( ( '+' | '-' )? ( ( DIGIT )* '.' unsigned_integer ) | ( DIGIT )+ '.' ) ( EXPONENT )? );
 */
static const ANTLR3_INT32 dfa27_eot[6] =
    {
        -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa27_eof[6] =
    {
        -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa27_min[6] =
    {
        11, 11, 11, -1, 11, -1
    };
static const ANTLR3_INT32 dfa27_max[6] =
    {
        34, 31, 31, -1, 31, -1
    };
static const ANTLR3_INT32 dfa27_accept[6] =
    {
        -1, -1, -1, 2, -1, 1
    };
static const ANTLR3_INT32 dfa27_special[6] =
    {
        -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa27_T_empty       NULL

static const ANTLR3_INT32 dfa27_T0[] =
    {
        4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 3
    };static const ANTLR3_INT32 dfa27_T1[] =
    {
        2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 3, -1, 1, 1
    };static const ANTLR3_INT32 dfa27_T2[] =
    {
        2, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 3
    };static const ANTLR3_INT32 dfa27_T3[] =
    {
        4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa27_transitions[] =
{
    dfa27_T1, dfa27_T3, dfa27_T2, dfa27_T_empty, dfa27_T0, dfa27_T_empty
};


/* Declare tracking structure for Cyclic DFA 27
 */
static
ANTLR3_CYCLIC_DFA cdfa27
    =   {
            27,             /* Decision number of this dfa          */
            /* Which decision this represents:   */
            (const pANTLR3_UCHAR)"126:1: float_ : ( integer EXPONENT | ( ( '+' | '-' )? ( ( DIGIT )* '.' unsigned_integer ) | ( DIGIT )+ '.' ) ( EXPONENT )? );",
            (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,        /* Default special state transition function    */
            antlr3dfaspecialTransition,         /* DFA specialTransition is currently just a default function in the runtime */
            antlr3dfapredict,                   /* DFA simulator function is in the runtime */
            dfa27_eot,      /* EOT table                            */
            dfa27_eof,      /* EOF table                            */
            dfa27_min,      /* Minimum tokens for each state    */
            dfa27_max,      /* Maximum tokens for each state    */
            dfa27_accept,       /* Accept table                     */
            dfa27_special,      /* Special transition states        */
            dfa27_transitions   /* Table of transition tables       */

        };
/* End of Cyclic DFA 27
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    127:24: ( ( '+' | '-' )? ( ( DIGIT )* '.' unsigned_integer ) | ( DIGIT )+ '.' )
 */
static const ANTLR3_INT32 dfa25_eot[5] =
    {
        -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa25_eof[5] =
    {
        -1, -1, -1, 4, -1
    };
static const ANTLR3_INT32 dfa25_min[5] =
    {
        11, -1, 11, 5, -1
    };
static const ANTLR3_INT32 dfa25_max[5] =
    {
        34, -1, 31, 35, -1
    };
static const ANTLR3_INT32 dfa25_accept[5] =
    {
        -1, 1, -1, -1, 2
    };
static const ANTLR3_INT32 dfa25_special[5] =
    {
        -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa25_T_empty       NULL

static const ANTLR3_INT32 dfa25_T0[] =
    {
        4, -1, -1, -1, 4, -1, 1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };static const ANTLR3_INT32 dfa25_T1[] =
    {
        2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 3
    };static const ANTLR3_INT32 dfa25_T2[] =
    {
        2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 1, -1, 1, 1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa25_transitions[] =
{
    dfa25_T2, dfa25_T_empty, dfa25_T1, dfa25_T0, dfa25_T_empty
};


/* Declare tracking structure for Cyclic DFA 25
 */
static
ANTLR3_CYCLIC_DFA cdfa25
    =   {
            25,             /* Decision number of this dfa          */
            /* Which decision this represents:   */
            (const pANTLR3_UCHAR)"127:24: ( ( '+' | '-' )? ( ( DIGIT )* '.' unsigned_integer ) | ( DIGIT )+ '.' )",
            (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,        /* Default special state transition function    */
            antlr3dfaspecialTransition,         /* DFA specialTransition is currently just a default function in the runtime */
            antlr3dfapredict,                   /* DFA simulator function is in the runtime */
            dfa25_eot,      /* EOT table                            */
            dfa25_eof,      /* EOF table                            */
            dfa25_min,      /* Minimum tokens for each state    */
            dfa25_max,      /* Maximum tokens for each state    */
            dfa25_accept,       /* Accept table                     */
            dfa25_special,      /* Special transition states        */
            dfa25_transitions   /* Table of transition tables       */

        };
/* End of Cyclic DFA 25
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    129:1: number : ( integer | float_ );
 */
static const ANTLR3_INT32 dfa28_eot[6] =
    {
        -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa28_eof[6] =
    {
        -1, -1, 5, -1, 5, -1
    };
static const ANTLR3_INT32 dfa28_min[6] =
    {
        11, 11, 5, -1, 5, -1
    };
static const ANTLR3_INT32 dfa28_max[6] =
    {
        34, 31, 35, -1, 35, -1
    };
static const ANTLR3_INT32 dfa28_accept[6] =
    {
        -1, -1, -1, 2, -1, 1
    };
static const ANTLR3_INT32 dfa28_special[6] =
    {
        -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa28_T_empty       NULL

static const ANTLR3_INT32 dfa28_T0[] =
    {
        4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 3
    };static const ANTLR3_INT32 dfa28_T1[] =
    {
        5, -1, -1, -1, 5, -1, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, 5
    };static const ANTLR3_INT32 dfa28_T2[] =
    {
        2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 3, -1, 1, 1
    };static const ANTLR3_INT32 dfa28_T3[] =
    {
        5, -1, -1, -1, 5, -1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, 5
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa28_transitions[] =
{
    dfa28_T2, dfa28_T0, dfa28_T3, dfa28_T_empty, dfa28_T1, dfa28_T_empty
};


/* Declare tracking structure for Cyclic DFA 28
 */
static
ANTLR3_CYCLIC_DFA cdfa28
    =   {
            28,             /* Decision number of this dfa          */
            /* Which decision this represents:   */
            (const pANTLR3_UCHAR)"129:1: number : ( integer | float_ );",
            (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,        /* Default special state transition function    */
            antlr3dfaspecialTransition,         /* DFA specialTransition is currently just a default function in the runtime */
            antlr3dfapredict,                   /* DFA simulator function is in the runtime */
            dfa28_eot,      /* EOT table                            */
            dfa28_eof,      /* EOF table                            */
            dfa28_min,      /* Minimum tokens for each state    */
            dfa28_max,      /* Maximum tokens for each state    */
            dfa28_accept,       /* Accept table                     */
            dfa28_special,      /* Special transition states        */
            dfa28_transitions   /* Table of transition tables       */

        };
/* End of Cyclic DFA 28
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    131:1: numeric : ( number | ( number '(' ( DIGIT )+ ')' ) );
 */
static const ANTLR3_INT32 dfa30_eot[11] =
    {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa30_eof[11] =
    {
        -1, -1, 8, -1, 8, 8, 8, -1, -1, 8, 8
    };
static const ANTLR3_INT32 dfa30_min[11] =
    {
        11, 11, 5, 11, 5, 5, 5, -1, -1, 5, 5
    };
static const ANTLR3_INT32 dfa30_max[11] =
    {
        34, 31, 35, 11, 35, 35, 35, -1, -1, 35, 35
    };
static const ANTLR3_INT32 dfa30_accept[11] =
    {
        -1, -1, -1, -1, -1, -1, -1, 2, 1, -1, -1
    };
static const ANTLR3_INT32 dfa30_special[11] =
    {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa30_T_empty       NULL

static const ANTLR3_INT32 dfa30_T0[] =
    {
        8, -1, -1, -1, 8, -1, 9, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7
    };static const ANTLR3_INT32 dfa30_T1[] =
    {
        2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 3, -1, 1, 1
    };static const ANTLR3_INT32 dfa30_T2[] =
    {
        9
    };static const ANTLR3_INT32 dfa30_T3[] =
    {
        8, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7
    };static const ANTLR3_INT32 dfa30_T4[] =
    {
        4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 3
    };static const ANTLR3_INT32 dfa30_T5[] =
    {
        8, -1, -1, -1, 8, -1, 2, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, 7
    };static const ANTLR3_INT32 dfa30_T6[] =
    {
        8, -1, -1, -1, 8, -1, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, 7
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa30_transitions[] =
{
    dfa30_T1, dfa30_T4, dfa30_T5, dfa30_T2, dfa30_T6, dfa30_T3, dfa30_T0,
    dfa30_T_empty, dfa30_T_empty, dfa30_T0, dfa30_T3
};


/* Declare tracking structure for Cyclic DFA 30
 */
static
ANTLR3_CYCLIC_DFA cdfa30
    =   {
            30,             /* Decision number of this dfa          */
            /* Which decision this represents:   */
            (const pANTLR3_UCHAR)"131:1: numeric : ( number | ( number '(' ( DIGIT )+ ')' ) );",
            (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,        /* Default special state transition function    */
            antlr3dfaspecialTransition,         /* DFA specialTransition is currently just a default function in the runtime */
            antlr3dfapredict,                   /* DFA simulator function is in the runtime */
            dfa30_eot,      /* EOT table                            */
            dfa30_eof,      /* EOF table                            */
            dfa30_min,      /* Minimum tokens for each state    */
            dfa30_max,      /* Maximum tokens for each state    */
            dfa30_accept,       /* Accept table                     */
            dfa30_special,      /* Special transition states        */
            dfa30_transitions   /* Table of transition tables       */

        };
/* End of Cyclic DFA 30
 * ---------------------
 */
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start parse
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:49:1: parse[boost::python::object & builder_] : cif EOF ;
 */
static void
parse(pcifParser ctx, boost::python::object & builder_)
{
    /* Initialize rule variables
     */

    ctx->pcifParser_parseTop = pcifParser_parsePush(ctx);
        (SCOPE_TOP(parse))->builder= new boost::python::object(builder_);
    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:54:2: ( cif EOF )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:54:4: cif EOF
        {
            FOLLOWPUSH(FOLLOW_cif_in_parse58);
            cif(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparseEx;
            }

             MATCHT(EOF, &FOLLOW_EOF_in_parse60);
            if  (HASEXCEPTION())
            {
                goto ruleparseEx;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto ruleparseEx; /* Prevent compiler warnings */
    ruleparseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     delete     (SCOPE_TOP(parse))->builder;
                }
            }

    pcifParser_parsePop(ctx);

    return ;
}
/* $ANTLR end parse */

/**
 * $ANTLR start cif
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:59:1: cif : ( COMMENTS )? ( WHITESPACE )* ( data_block ( ( WHITESPACE )* data_block )* ( WHITESPACE )? )? ;
 */
static void
cif(pcifParser ctx)
{
    /* Initialize rule variables
     */


    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:2: ( ( COMMENTS )? ( WHITESPACE )* ( data_block ( ( WHITESPACE )* data_block )* ( WHITESPACE )? )? )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:4: ( COMMENTS )? ( WHITESPACE )* ( data_block ( ( WHITESPACE )* data_block )* ( WHITESPACE )? )?
        {

            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:4: ( COMMENTS )?
            {
                int alt1=2;
                switch ( LA(1) )
                {
                    case COMMENTS:
                        {
                                alt1=1;
                        }
                        break;
                }

                switch (alt1)
                {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:5: COMMENTS
                    {
                         MATCHT(COMMENTS, &FOLLOW_COMMENTS_in_cif73);
                        if  (HASEXCEPTION())
                        {
                            goto rulecifEx;
                        }


                    }
                    break;

                }
            }

            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:16: ( WHITESPACE )*

            for (;;)
            {
                int alt2=2;
                switch ( LA(1) )
                {
                case WHITESPACE:
                        {
                                alt2=1;
                        }
                    break;

                }

                switch (alt2)
                {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:17: WHITESPACE
                    {
                         MATCHT(WHITESPACE, &FOLLOW_WHITESPACE_in_cif78);
                        if  (HASEXCEPTION())
                        {
                            goto rulecifEx;
                        }


                    }
                    break;

                default:
                    goto loop2; /* break out of the loop */
                    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */


            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:30: ( data_block ( ( WHITESPACE )* data_block )* ( WHITESPACE )? )?
            {
                int alt6=2;
                switch ( LA(1) )
                {
                    case DATA_BLOCK_HEADING:
                        {
                                alt6=1;
                        }
                        break;
                }

                switch (alt6)
                {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:32: data_block ( ( WHITESPACE )* data_block )* ( WHITESPACE )?
                    {
                        FOLLOWPUSH(FOLLOW_data_block_in_cif84);
                        data_block(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto rulecifEx;
                        }


                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:43: ( ( WHITESPACE )* data_block )*

                        for (;;)
                        {
                            int alt4=2;
                            switch ( LA(1) )
                            {
                            case WHITESPACE:
                                {
                                        switch ( LA(2) )
                                        {
                                        case WHITESPACE:
                                        case DATA_BLOCK_HEADING:
                                                {
                                                        alt4=1;
                                                }
                                            break;

                                        }

                                }
                                break;
                            case DATA_BLOCK_HEADING:
                                {
                                        alt4=1;
                                }
                                break;

                            }

                            switch (alt4)
                            {
                                case 1:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:45: ( WHITESPACE )* data_block
                                    {

                                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:45: ( WHITESPACE )*

                                        for (;;)
                                        {
                                            int alt3=2;
                                            switch ( LA(1) )
                                            {
                                            case WHITESPACE:
                                                {
                                                        alt3=1;
                                                }
                                                break;

                                            }

                                            switch (alt3)
                                            {
                                                case 1:
                                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:45: WHITESPACE
                                                    {
                                                         MATCHT(WHITESPACE, &FOLLOW_WHITESPACE_in_cif88);
                                                        if  (HASEXCEPTION())
                                                        {
                                                            goto rulecifEx;
                                                        }


                                                    }
                                                    break;

                                                default:
                                                    goto loop3; /* break out of the loop */
                                                    break;
                                            }
                                        }
                                        loop3: ; /* Jump out to here if this rule does not match */

                                        FOLLOWPUSH(FOLLOW_data_block_in_cif91);
                                        data_block(ctx);

                                        FOLLOWPOP();
                                        if  (HASEXCEPTION())
                                        {
                                            goto rulecifEx;
                                        }


                                    }
                                    break;

                                default:
                                    goto loop4; /* break out of the loop */
                                    break;
                            }
                        }
                        loop4: ; /* Jump out to here if this rule does not match */


                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:71: ( WHITESPACE )?
                        {
                            int alt5=2;
                            switch ( LA(1) )
                            {
                                case WHITESPACE:
                                        {
                                                alt5=1;
                                        }
                                    break;
                            }

                            switch (alt5)
                            {
                                case 1:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:60:72: WHITESPACE
                                    {
                                         MATCHT(WHITESPACE, &FOLLOW_WHITESPACE_in_cif97);
                                        if  (HASEXCEPTION())
                                        {
                                            goto rulecifEx;
                                        }


                                    }
                                    break;

                            }
                        }

                    }
                    break;

                }
            }

        }

    }


    // This is where rules clean up and exit
    //
    goto rulecifEx; /* Prevent compiler warnings */
    rulecifEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end cif */

/**
 * $ANTLR start loop_body
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:63:1: loop_body : v1= value ( ( WHITESPACE )+ v2= value )* ;
 */
static void
loop_body(pcifParser ctx)
{
    cifParser_value_return v1;
    #undef      RETURN_TYPE_v1
    #define     RETURN_TYPE_v1 cifParser_value_return

    cifParser_value_return v2;
    #undef      RETURN_TYPE_v2
    #define     RETURN_TYPE_v2 cifParser_value_return

    /* Initialize rule variables
     */


    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:64:2: (v1= value ( ( WHITESPACE )+ v2= value )* )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:64:4: v1= value ( ( WHITESPACE )+ v2= value )*
        {
            FOLLOWPUSH(FOLLOW_value_in_loop_body115);
            v1=value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleloop_bodyEx;
            }

            {
                 (      (SCOPE_TOP(data_items))->curr_loop_values)->push_back(to_std_string((STRSTREAM->toStringTT(STRSTREAM, v1.start, v1.stop))));
            }

            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:66:8: ( ( WHITESPACE )+ v2= value )*

            for (;;)
            {
                int alt8=2;
                alt8 = cdfa8.predict(ctx, RECOGNIZER, ISTREAM, &cdfa8);
                if  (HASEXCEPTION())
                {
                    goto ruleloop_bodyEx;
                }

                switch (alt8)
                {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:66:10: ( WHITESPACE )+ v2= value
                    {
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:66:10: ( WHITESPACE )+
                        {
                            int cnt7=0;

                            for (;;)
                            {
                                int alt7=2;
                                switch ( LA(1) )
                                {
                                case WHITESPACE:
                                        {
                                                alt7=1;
                                        }
                                    break;

                                }

                                switch (alt7)
                                {
                                    case 1:
                                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:66:10: WHITESPACE
                                        {
                                             MATCHT(WHITESPACE, &FOLLOW_WHITESPACE_in_loop_body128);
                                            if  (HASEXCEPTION())
                                            {
                                                goto ruleloop_bodyEx;
                                            }


                                        }
                                        break;

                                    default:

                                        if ( cnt7 >= 1 )
                                        {
                                            goto loop7;
                                        }
                                        /* mismatchedSetEx()
                                         */
                                        CONSTRUCTEX();
                                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                                        goto ruleloop_bodyEx;
                                }
                                cnt7++;
                            }
                            loop7: ;    /* Jump to here if this rule does not match */
                        }
                        FOLLOWPUSH(FOLLOW_value_in_loop_body142);
                        v2=value(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto ruleloop_bodyEx;
                        }

                        {
                             (  (SCOPE_TOP(data_items))->curr_loop_values)->push_back(to_std_string((STRSTREAM->toStringTT(STRSTREAM, v2.start, v2.stop))));
                        }

                    }
                    break;

                default:
                    goto loop8; /* break out of the loop */
                    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


        }

    }


    // This is where rules clean up and exit
    //
    goto ruleloop_bodyEx; /* Prevent compiler warnings */
    ruleloop_bodyEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end loop_body */

/**
 * $ANTLR start save_frame
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:72:1: save_frame : SAVE_FRAME_HEADING ( ( WHITESPACE )+ data_items )+ ( WHITESPACE )+ SAVE ;
 */
static void
save_frame(pcifParser ctx)
{
    /* Initialize rule variables
     */


    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:73:2: ( SAVE_FRAME_HEADING ( ( WHITESPACE )+ data_items )+ ( WHITESPACE )+ SAVE )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:73:4: SAVE_FRAME_HEADING ( ( WHITESPACE )+ data_items )+ ( WHITESPACE )+ SAVE
        {
             MATCHT(SAVE_FRAME_HEADING, &FOLLOW_SAVE_FRAME_HEADING_in_save_frame166);
            if  (HASEXCEPTION())
            {
                goto rulesave_frameEx;
            }

            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:73:23: ( ( WHITESPACE )+ data_items )+
            {
                int cnt10=0;

                for (;;)
                {
                    int alt10=2;
                alt10 = cdfa10.predict(ctx, RECOGNIZER, ISTREAM, &cdfa10);
                if  (HASEXCEPTION())
                {
                    goto rulesave_frameEx;
                }

                switch (alt10)
                {
                    case 1:
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:73:25: ( WHITESPACE )+ data_items
                        {
                            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:73:25: ( WHITESPACE )+
                            {
                                int cnt9=0;

                                for (;;)
                                {
                                    int alt9=2;
                                switch ( LA(1) )
                                {
                                case WHITESPACE:
                                        {
                                                alt9=1;
                                        }
                                    break;

                                }

                                switch (alt9)
                                {
                                    case 1:
                                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:73:25: WHITESPACE
                                        {
                                             MATCHT(WHITESPACE, &FOLLOW_WHITESPACE_in_save_frame170);
                                            if  (HASEXCEPTION())
                                            {
                                                goto rulesave_frameEx;
                                            }


                                        }
                                        break;

                                    default:

                                        if ( cnt9 >= 1 )
                                        {
                                            goto loop9;
                                        }
                                        /* mismatchedSetEx()
                                         */
                                        CONSTRUCTEX();
                                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                                        goto rulesave_frameEx;
                                }
                                cnt9++;
                                }
                                loop9: ;        /* Jump to here if this rule does not match */
                            }
                            FOLLOWPUSH(FOLLOW_data_items_in_save_frame173);
                            data_items(ctx);

                            FOLLOWPOP();
                            if  (HASEXCEPTION())
                            {
                                goto rulesave_frameEx;
                            }


                        }
                        break;

                    default:

                        if ( cnt10 >= 1 )
                        {
                            goto loop10;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto rulesave_frameEx;
                }
                cnt10++;
                }
                loop10: ;       /* Jump to here if this rule does not match */
            }
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:73:51: ( WHITESPACE )+
            {
                int cnt11=0;

                for (;;)
                {
                    int alt11=2;
                switch ( LA(1) )
                {
                case WHITESPACE:
                        {
                                alt11=1;
                        }
                    break;

                }

                switch (alt11)
                {
                    case 1:
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:73:51: WHITESPACE
                        {
                             MATCHT(WHITESPACE, &FOLLOW_WHITESPACE_in_save_frame178);
                            if  (HASEXCEPTION())
                            {
                                goto rulesave_frameEx;
                            }


                        }
                        break;

                    default:

                        if ( cnt11 >= 1 )
                        {
                            goto loop11;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto rulesave_frameEx;
                }
                cnt11++;
                }
                loop11: ;       /* Jump to here if this rule does not match */
            }
             MATCHT(SAVE, &FOLLOW_SAVE_in_save_frame181);
            if  (HASEXCEPTION())
            {
                goto rulesave_frameEx;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto rulesave_frameEx; /* Prevent compiler warnings */
    rulesave_frameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end save_frame */

/**
 * $ANTLR start data_items
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:75:1: data_items : ( TAG WHITESPACE value | loop_header ( WHITESPACE )* loop_body );
 */
static void
data_items(pcifParser ctx)
{
    pANTLR3_COMMON_TOKEN    TAG1;
    cifParser_value_return value2;
    #undef      RETURN_TYPE_value2
    #define     RETURN_TYPE_value2 cifParser_value_return

    cifParser_loop_header_return loop_header3;
    #undef      RETURN_TYPE_loop_header3
    #define     RETURN_TYPE_loop_header3 cifParser_loop_header_return

    /* Initialize rule variables
     */

    ctx->pcifParser_data_itemsTop = pcifParser_data_itemsPush(ctx);
        (SCOPE_TOP(data_items))->curr_loop_values= new scitbx::af::shared<std::string>();
    TAG1       = NULL;

    {
        {
            //  C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:79:2: ( TAG WHITESPACE value | loop_header ( WHITESPACE )* loop_body )

            ANTLR3_UINT32 alt13;

            alt13=2;

            switch ( LA(1) )
            {
            case TAG:
                {
                        alt13=1;
                }
                break;
            case LOOP_:
                {
                        alt13=2;
                }
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 13;
                EXCEPTION->state        = 0;


                goto ruledata_itemsEx;
            }

            switch (alt13)
            {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:79:4: TAG WHITESPACE value
                    {
                        TAG1 = (pANTLR3_COMMON_TOKEN) MATCHT(TAG, &FOLLOW_TAG_in_data_items205);
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }

                         MATCHT(WHITESPACE, &FOLLOW_WHITESPACE_in_data_items207);
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }

                        FOLLOWPUSH(FOLLOW_value_in_data_items209);
                        value2=value(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }

                        {

                              ( (SCOPE_TOP(parse))->builder)->attr("add_data_item")(
                              to_std_string((TAG1->getText(TAG1))),
                              to_std_string((STRSTREAM->toStringTT(STRSTREAM, value2.start, value2.stop))));

                        }

                    }
                    break;
                case 2:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:85:10: loop_header ( WHITESPACE )* loop_body
                    {
                        FOLLOWPUSH(FOLLOW_loop_header_in_data_items222);
                        loop_header3=loop_header(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }


                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:85:22: ( WHITESPACE )*

                        for (;;)
                        {
                            int alt12=2;
                            switch ( LA(1) )
                            {
                            case WHITESPACE:
                                {
                                        alt12=1;
                                }
                                break;

                            }

                            switch (alt12)
                            {
                                case 1:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:85:22: WHITESPACE
                                    {
                                         MATCHT(WHITESPACE, &FOLLOW_WHITESPACE_in_data_items224);
                                        if  (HASEXCEPTION())
                                        {
                                            goto ruledata_itemsEx;
                                        }


                                    }
                                    break;

                                default:
                                    goto loop12;        /* break out of the loop */
                                    break;
                            }
                        }
                        loop12: ; /* Jump out to here if this rule does not match */

                        FOLLOWPUSH(FOLLOW_loop_body_in_data_items227);
                        loop_body(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto ruledata_itemsEx;
                        }

                        {

                              scitbx::af::shared<std::string> &values = *(      (SCOPE_TOP(data_items))->curr_loop_values);
                              try {
                                (       (SCOPE_TOP(parse))->builder)->attr("add_loop")(to_std_string((STRSTREAM->toStringTT(STRSTREAM, loop_header3.start, loop_header3.stop))), values);
                              }
                              catch (boost::python::error_already_set&) {
                                PyErr_Clear();
                              }

                        }

                    }
                    break;

            }
        }
    }


    // This is where rules clean up and exit
    //
    goto ruledata_itemsEx; /* Prevent compiler warnings */
    ruledata_itemsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     delete     (SCOPE_TOP(data_items))->curr_loop_values;
                }
            }

    pcifParser_data_itemsPop(ctx);

    return ;
}
/* $ANTLR end data_items */

/**
 * $ANTLR start data_block
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:97:1: data_block : DATA_BLOCK_HEADING ( ( WHITESPACE )+ ( data_items | save_frame ) )* ;
 */
static void
data_block(pcifParser ctx)
{
    pANTLR3_COMMON_TOKEN    DATA_BLOCK_HEADING4;

    /* Initialize rule variables
     */


    DATA_BLOCK_HEADING4       = NULL;

    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:98:2: ( DATA_BLOCK_HEADING ( ( WHITESPACE )+ ( data_items | save_frame ) )* )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:98:4: DATA_BLOCK_HEADING ( ( WHITESPACE )+ ( data_items | save_frame ) )*
        {
            DATA_BLOCK_HEADING4 = (pANTLR3_COMMON_TOKEN) MATCHT(DATA_BLOCK_HEADING, &FOLLOW_DATA_BLOCK_HEADING_in_data_block240);
            if  (HASEXCEPTION())
            {
                goto ruledata_blockEx;
            }

            {
                 (      (SCOPE_TOP(parse))->builder)->attr("add_data_block")(to_std_string((DATA_BLOCK_HEADING4->getText(DATA_BLOCK_HEADING4))));
            }

            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:100:8: ( ( WHITESPACE )+ ( data_items | save_frame ) )*

            for (;;)
            {
                int alt16=2;
                alt16 = cdfa16.predict(ctx, RECOGNIZER, ISTREAM, &cdfa16);
                if  (HASEXCEPTION())
                {
                    goto ruledata_blockEx;
                }

                switch (alt16)
                {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:100:10: ( WHITESPACE )+ ( data_items | save_frame )
                    {
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:100:10: ( WHITESPACE )+
                        {
                            int cnt14=0;

                            for (;;)
                            {
                                int alt14=2;
                                switch ( LA(1) )
                                {
                                case WHITESPACE:
                                        {
                                                alt14=1;
                                        }
                                    break;

                                }

                                switch (alt14)
                                {
                                    case 1:
                                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:100:10: WHITESPACE
                                        {
                                             MATCHT(WHITESPACE, &FOLLOW_WHITESPACE_in_data_block253);
                                            if  (HASEXCEPTION())
                                            {
                                                goto ruledata_blockEx;
                                            }


                                        }
                                        break;

                                    default:

                                        if ( cnt14 >= 1 )
                                        {
                                            goto loop14;
                                        }
                                        /* mismatchedSetEx()
                                         */
                                        CONSTRUCTEX();
                                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                                        goto ruledata_blockEx;
                                }
                                cnt14++;
                            }
                            loop14: ;   /* Jump to here if this rule does not match */
                        }

                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:100:22: ( data_items | save_frame )
                        {
                            int alt15=2;
                            switch ( LA(1) )
                            {
                            case TAG:
                            case LOOP_:
                                {
                                        alt15=1;
                                }
                                break;
                            case SAVE_FRAME_HEADING:
                                {
                                        alt15=2;
                                }
                                break;

                            default:
                                CONSTRUCTEX();
                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                EXCEPTION->message      = (void *)"";
                                EXCEPTION->decisionNum  = 15;
                                EXCEPTION->state        = 0;


                                goto ruledata_blockEx;
                            }

                            switch (alt15)
                            {
                                case 1:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:100:24: data_items
                                    {
                                        FOLLOWPUSH(FOLLOW_data_items_in_data_block258);
                                        data_items(ctx);

                                        FOLLOWPOP();
                                        if  (HASEXCEPTION())
                                        {
                                            goto ruledata_blockEx;
                                        }


                                    }
                                    break;
                                case 2:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:100:37: save_frame
                                    {
                                        FOLLOWPUSH(FOLLOW_save_frame_in_data_block262);
                                        save_frame(ctx);

                                        FOLLOWPOP();
                                        if  (HASEXCEPTION())
                                        {
                                            goto ruledata_blockEx;
                                        }


                                    }
                                    break;

                            }
                        }

                    }
                    break;

                default:
                    goto loop16;        /* break out of the loop */
                    break;
                }
            }
            loop16: ; /* Jump out to here if this rule does not match */


        }

    }


    // This is where rules clean up and exit
    //
    goto ruledata_blockEx; /* Prevent compiler warnings */
    ruledata_blockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end data_block */

/**
 * $ANTLR start loop_header
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:103:1: loop_header : LOOP_ ( ( WHITESPACE )+ TAG )+ WHITESPACE ;
 */
static cifParser_loop_header_return
loop_header(pcifParser ctx)
{
    cifParser_loop_header_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:104:2: ( LOOP_ ( ( WHITESPACE )+ TAG )+ WHITESPACE )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:104:4: LOOP_ ( ( WHITESPACE )+ TAG )+ WHITESPACE
        {
             MATCHT(LOOP_, &FOLLOW_LOOP__in_loop_header278);
            if  (HASEXCEPTION())
            {
                goto ruleloop_headerEx;
            }

            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:104:10: ( ( WHITESPACE )+ TAG )+
            {
                int cnt18=0;

                for (;;)
                {
                    int alt18=2;
                alt18 = cdfa18.predict(ctx, RECOGNIZER, ISTREAM, &cdfa18);
                if  (HASEXCEPTION())
                {
                    goto ruleloop_headerEx;
                }

                switch (alt18)
                {
                    case 1:
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:104:12: ( WHITESPACE )+ TAG
                        {
                            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:104:12: ( WHITESPACE )+
                            {
                                int cnt17=0;

                                for (;;)
                                {
                                    int alt17=2;
                                switch ( LA(1) )
                                {
                                case WHITESPACE:
                                        {
                                                alt17=1;
                                        }
                                    break;

                                }

                                switch (alt17)
                                {
                                    case 1:
                                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:104:12: WHITESPACE
                                        {
                                             MATCHT(WHITESPACE, &FOLLOW_WHITESPACE_in_loop_header282);
                                            if  (HASEXCEPTION())
                                            {
                                                goto ruleloop_headerEx;
                                            }


                                        }
                                        break;

                                    default:

                                        if ( cnt17 >= 1 )
                                        {
                                            goto loop17;
                                        }
                                        /* mismatchedSetEx()
                                         */
                                        CONSTRUCTEX();
                                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                                        goto ruleloop_headerEx;
                                }
                                cnt17++;
                                }
                                loop17: ;       /* Jump to here if this rule does not match */
                            }
                             MATCHT(TAG, &FOLLOW_TAG_in_loop_header285);
                            if  (HASEXCEPTION())
                            {
                                goto ruleloop_headerEx;
                            }


                        }
                        break;

                    default:

                        if ( cnt18 >= 1 )
                        {
                            goto loop18;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleloop_headerEx;
                }
                cnt18++;
                }
                loop18: ;       /* Jump to here if this rule does not match */
            }
             MATCHT(WHITESPACE, &FOLLOW_WHITESPACE_in_loop_header290);
            if  (HASEXCEPTION())
            {
                goto ruleloop_headerEx;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto ruleloop_headerEx; /* Prevent compiler warnings */
    ruleloop_headerEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end loop_header */

/**
 * $ANTLR start inapplicable
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:111:1: inapplicable : '.' ;
 */
static void
inapplicable(pcifParser ctx)
{
    /* Initialize rule variables
     */


    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:112:2: ( '.' )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:112:4: '.'
        {
             MATCHT(31, &FOLLOW_31_in_inapplicable304);
            if  (HASEXCEPTION())
            {
                goto ruleinapplicableEx;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto ruleinapplicableEx; /* Prevent compiler warnings */
    ruleinapplicableEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end inapplicable */

/**
 * $ANTLR start unknown
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:114:1: unknown : '?' ;
 */
static void
unknown(pcifParser ctx)
{
    /* Initialize rule variables
     */


    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:114:9: ( '?' )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:114:11: '?'
        {
             MATCHT(32, &FOLLOW_32_in_unknown313);
            if  (HASEXCEPTION())
            {
                goto ruleunknownEx;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto ruleunknownEx; /* Prevent compiler warnings */
    ruleunknownEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end unknown */

/**
 * $ANTLR start value
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:116:1: value : ( inapplicable | unknown | '-' | char_string | numeric | text_field );
 */
static cifParser_value_return
value(pcifParser ctx)
{
    cifParser_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:116:8: ( inapplicable | unknown | '-' | char_string | numeric | text_field )

            ANTLR3_UINT32 alt19;

            alt19=6;

            switch ( LA(1) )
            {
            case 31:
                {
                        switch ( LA(2) )
                        {
                        case EOF:
                        case WHITESPACE:
                        case DATA_BLOCK_HEADING:
                                {
                                        alt19=1;
                                }
                            break;
                        case DIGIT:
                                {
                                        alt19=5;
                                }
                            break;

                        default:
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 19;
                            EXCEPTION->state        = 1;


                            goto rulevalueEx;
                        }

                }
                break;
            case 32:
                {
                        alt19=2;
                }
                break;
            case 33:
                {
                        switch ( LA(2) )
                        {
                        case DIGIT:
                        case 31:
                                {
                                        alt19=5;
                                }
                            break;
                        case EOF:
                        case WHITESPACE:
                        case DATA_BLOCK_HEADING:
                                {
                                        alt19=3;
                                }
                            break;

                        default:
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 19;
                            EXCEPTION->state        = 3;


                            goto rulevalueEx;
                        }

                }
                break;
            case CHAR_STRING:
                {
                        alt19=4;
                }
                break;
            case DIGIT:
            case 34:
                {
                        alt19=5;
                }
                break;
            case SEMI_COLON_TEXT_FIELD:
                {
                        alt19=6;
                }
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 19;
                EXCEPTION->state        = 0;


                goto rulevalueEx;
            }

            switch (alt19)
            {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:116:10: inapplicable
                    {
                        FOLLOWPUSH(FOLLOW_inapplicable_in_value323);
                        inapplicable(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto rulevalueEx;
                        }


                    }
                    break;
                case 2:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:116:25: unknown
                    {
                        FOLLOWPUSH(FOLLOW_unknown_in_value327);
                        unknown(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto rulevalueEx;
                        }


                    }
                    break;
                case 3:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:116:35: '-'
                    {
                         MATCHT(33, &FOLLOW_33_in_value331);
                        if  (HASEXCEPTION())
                        {
                            goto rulevalueEx;
                        }


                    }
                    break;
                case 4:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:116:41: char_string
                    {
                        FOLLOWPUSH(FOLLOW_char_string_in_value335);
                        char_string(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto rulevalueEx;
                        }


                    }
                    break;
                case 5:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:116:56: numeric
                    {
                        FOLLOWPUSH(FOLLOW_numeric_in_value340);
                        numeric(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto rulevalueEx;
                        }


                    }
                    break;
                case 6:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:116:65: text_field
                    {
                        FOLLOWPUSH(FOLLOW_text_field_in_value343);
                        text_field(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto rulevalueEx;
                        }


                    }
                    break;

            }
        }
    }


    // This is where rules clean up and exit
    //
    goto rulevalueEx; /* Prevent compiler warnings */
    rulevalueEx: ;
    retval.stop = LT(-1);

    if  (HASEXCEPTION())
    {
        /* catch(decl,action)
         */
        {


        }


    }
    else
    {
    }

    return retval;
}
/* $ANTLR end value */

/**
 * $ANTLR start unsigned_integer
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:121:1: unsigned_integer : ( DIGIT )+ ;
 */
static void
unsigned_integer(pcifParser ctx)
{
    /* Initialize rule variables
     */


    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:122:2: ( ( DIGIT )+ )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:122:4: ( DIGIT )+
        {
            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:122:4: ( DIGIT )+
            {
                int cnt20=0;

                for (;;)
                {
                    int alt20=2;
                switch ( LA(1) )
                {
                case DIGIT:
                        {
                                alt20=1;
                        }
                    break;

                }

                switch (alt20)
                {
                    case 1:
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:122:5: DIGIT
                        {
                             MATCHT(DIGIT, &FOLLOW_DIGIT_in_unsigned_integer362);
                            if  (HASEXCEPTION())
                            {
                                goto ruleunsigned_integerEx;
                            }


                        }
                        break;

                    default:

                        if ( cnt20 >= 1 )
                        {
                            goto loop20;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleunsigned_integerEx;
                }
                cnt20++;
                }
                loop20: ;       /* Jump to here if this rule does not match */
            }

        }

    }


    // This is where rules clean up and exit
    //
    goto ruleunsigned_integerEx; /* Prevent compiler warnings */
    ruleunsigned_integerEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end unsigned_integer */

/**
 * $ANTLR start integer
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:124:1: integer : ( '+' | '-' )? unsigned_integer ;
 */
static void
integer(pcifParser ctx)
{
    /* Initialize rule variables
     */


    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:124:9: ( ( '+' | '-' )? unsigned_integer )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:124:12: ( '+' | '-' )? unsigned_integer
        {

            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:124:12: ( '+' | '-' )?
            {
                int alt21=2;
                switch ( LA(1) )
                {
                    case 33:
                    case 34:
                        {
                                alt21=1;
                        }
                        break;
                }

                switch (alt21)
                {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:
                    {
                        if ( ((LA(1) >= 33) && (LA(1) <= 34)) )
                        {
                            CONSUME();
                            PERRORRECOVERY=ANTLR3_FALSE;
                        }
                        else
                        {
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                            EXCEPTION->expectingSet = &FOLLOW_set_in_integer374;
                            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_integer374);    goto ruleintegerEx;
                        }


                    }
                    break;

                }
            }
            FOLLOWPUSH(FOLLOW_unsigned_integer_in_integer385);
            unsigned_integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleintegerEx;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto ruleintegerEx; /* Prevent compiler warnings */
    ruleintegerEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end integer */

/**
 * $ANTLR start float_
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:126:1: float_ : ( integer EXPONENT | ( ( '+' | '-' )? ( ( DIGIT )* '.' unsigned_integer ) | ( DIGIT )+ '.' ) ( EXPONENT )? );
 */
static void
float_(pcifParser ctx)
{
    /* Initialize rule variables
     */


    {
        {
            //  C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:2: ( integer EXPONENT | ( ( '+' | '-' )? ( ( DIGIT )* '.' unsigned_integer ) | ( DIGIT )+ '.' ) ( EXPONENT )? )

            ANTLR3_UINT32 alt27;

            alt27=2;

            alt27 = cdfa27.predict(ctx, RECOGNIZER, ISTREAM, &cdfa27);
            if  (HASEXCEPTION())
            {
                goto rulefloat_Ex;
            }

            switch (alt27)
            {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:5: integer EXPONENT
                    {
                        FOLLOWPUSH(FOLLOW_integer_in_float_396);
                        integer(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto rulefloat_Ex;
                        }

                         MATCHT(EXPONENT, &FOLLOW_EXPONENT_in_float_398);
                        if  (HASEXCEPTION())
                        {
                            goto rulefloat_Ex;
                        }


                    }
                    break;
                case 2:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:24: ( ( '+' | '-' )? ( ( DIGIT )* '.' unsigned_integer ) | ( DIGIT )+ '.' ) ( EXPONENT )?
                    {

                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:24: ( ( '+' | '-' )? ( ( DIGIT )* '.' unsigned_integer ) | ( DIGIT )+ '.' )
                        {
                            int alt25=2;
                            alt25 = cdfa25.predict(ctx, RECOGNIZER, ISTREAM, &cdfa25);
                            if  (HASEXCEPTION())
                            {
                                goto rulefloat_Ex;
                            }

                            switch (alt25)
                            {
                                case 1:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:26: ( '+' | '-' )? ( ( DIGIT )* '.' unsigned_integer )
                                    {

                                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:26: ( '+' | '-' )?
                                        {
                                            int alt22=2;
                                            switch ( LA(1) )
                                            {
                                                case 33:
                                                case 34:
                                                        {
                                                                alt22=1;
                                                        }
                                                    break;
                                            }

                                            switch (alt22)
                                            {
                                                case 1:
                                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:
                                                    {
                                                        if ( ((LA(1) >= 33) && (LA(1) <= 34)) )
                                                        {
                                                            CONSUME();
                                                            PERRORRECOVERY=ANTLR3_FALSE;
                                                        }
                                                        else
                                                        {
                                                            CONSTRUCTEX();
                                                            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                                                            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                                                            EXCEPTION->expectingSet = &FOLLOW_set_in_float_404;
                                                            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_float_404);    goto rulefloat_Ex;
                                                        }


                                                    }
                                                    break;

                                            }
                                        }
                                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:41: ( ( DIGIT )* '.' unsigned_integer )
                                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:43: ( DIGIT )* '.' unsigned_integer
                                        {

                                            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:43: ( DIGIT )*

                                            for (;;)
                                            {
                                                int alt23=2;
                                                switch ( LA(1) )
                                                {
                                                case DIGIT:
                                                        {
                                                                alt23=1;
                                                        }
                                                    break;

                                                }

                                                switch (alt23)
                                                {
                                                case 1:
                                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:44: DIGIT
                                                    {
                                                         MATCHT(DIGIT, &FOLLOW_DIGIT_in_float_418);
                                                        if  (HASEXCEPTION())
                                                        {
                                                            goto rulefloat_Ex;
                                                        }


                                                    }
                                                    break;

                                                default:
                                                    goto loop23;        /* break out of the loop */
                                                    break;
                                                }
                                            }
                                            loop23: ; /* Jump out to here if this rule does not match */

                                             MATCHT(31, &FOLLOW_31_in_float_422);
                                            if  (HASEXCEPTION())
                                            {
                                                goto rulefloat_Ex;
                                            }

                                            FOLLOWPUSH(FOLLOW_unsigned_integer_in_float_424);
                                            unsigned_integer(ctx);

                                            FOLLOWPOP();
                                            if  (HASEXCEPTION())
                                            {
                                                goto rulefloat_Ex;
                                            }


                                        }


                                    }
                                    break;
                                case 2:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:76: ( DIGIT )+ '.'
                                    {
                                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:76: ( DIGIT )+
                                        {
                                            int cnt24=0;

                                            for (;;)
                                            {
                                                int alt24=2;
                                                switch ( LA(1) )
                                                {
                                                case DIGIT:
                                                        {
                                                                alt24=1;
                                                        }
                                                    break;

                                                }

                                                switch (alt24)
                                                {
                                                    case 1:
                                                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:77: DIGIT
                                                        {
                                                             MATCHT(DIGIT, &FOLLOW_DIGIT_in_float_430);
                                                            if  (HASEXCEPTION())
                                                            {
                                                                goto rulefloat_Ex;
                                                            }


                                                        }
                                                        break;

                                                    default:

                                                        if ( cnt24 >= 1 )
                                                        {
                                                            goto loop24;
                                                        }
                                                        /* mismatchedSetEx()
                                                         */
                                                        CONSTRUCTEX();
                                                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                                                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                                                        goto rulefloat_Ex;
                                                }
                                                cnt24++;
                                            }
                                            loop24: ;   /* Jump to here if this rule does not match */
                                        }
                                         MATCHT(31, &FOLLOW_31_in_float_434);
                                        if  (HASEXCEPTION())
                                        {
                                            goto rulefloat_Ex;
                                        }


                                    }
                                    break;

                            }
                        }

                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:91: ( EXPONENT )?
                        {
                            int alt26=2;
                            switch ( LA(1) )
                            {
                                case EXPONENT:
                                        {
                                                alt26=1;
                                        }
                                    break;
                            }

                            switch (alt26)
                            {
                                case 1:
                                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:127:92: EXPONENT
                                    {
                                         MATCHT(EXPONENT, &FOLLOW_EXPONENT_in_float_439);
                                        if  (HASEXCEPTION())
                                        {
                                            goto rulefloat_Ex;
                                        }


                                    }
                                    break;

                            }
                        }

                    }
                    break;

            }
        }
    }


    // This is where rules clean up and exit
    //
    goto rulefloat_Ex; /* Prevent compiler warnings */
    rulefloat_Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end float_ */

/**
 * $ANTLR start number
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:129:1: number : ( integer | float_ );
 */
static void
number(pcifParser ctx)
{
    /* Initialize rule variables
     */


    {
        {
            //  C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:129:9: ( integer | float_ )

            ANTLR3_UINT32 alt28;

            alt28=2;

            alt28 = cdfa28.predict(ctx, RECOGNIZER, ISTREAM, &cdfa28);
            if  (HASEXCEPTION())
            {
                goto rulenumberEx;
            }

            switch (alt28)
            {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:129:11: integer
                    {
                        FOLLOWPUSH(FOLLOW_integer_in_number451);
                        integer(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto rulenumberEx;
                        }


                    }
                    break;
                case 2:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:129:21: float_
                    {
                        FOLLOWPUSH(FOLLOW_float__in_number455);
                        float_(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto rulenumberEx;
                        }


                    }
                    break;

            }
        }
    }


    // This is where rules clean up and exit
    //
    goto rulenumberEx; /* Prevent compiler warnings */
    rulenumberEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end number */

/**
 * $ANTLR start numeric
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:131:1: numeric : ( number | ( number '(' ( DIGIT )+ ')' ) );
 */
static void
numeric(pcifParser ctx)
{
    /* Initialize rule variables
     */


    {
        {
            //  C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:131:9: ( number | ( number '(' ( DIGIT )+ ')' ) )

            ANTLR3_UINT32 alt30;

            alt30=2;

            alt30 = cdfa30.predict(ctx, RECOGNIZER, ISTREAM, &cdfa30);
            if  (HASEXCEPTION())
            {
                goto rulenumericEx;
            }

            switch (alt30)
            {
                case 1:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:131:11: number
                    {
                        FOLLOWPUSH(FOLLOW_number_in_numeric464);
                        number(ctx);

                        FOLLOWPOP();
                        if  (HASEXCEPTION())
                        {
                            goto rulenumericEx;
                        }


                    }
                    break;
                case 2:
                    // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:131:20: ( number '(' ( DIGIT )+ ')' )
                    {
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:131:20: ( number '(' ( DIGIT )+ ')' )
                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:131:22: number '(' ( DIGIT )+ ')'
                        {
                            FOLLOWPUSH(FOLLOW_number_in_numeric470);
                            number(ctx);

                            FOLLOWPOP();
                            if  (HASEXCEPTION())
                            {
                                goto rulenumericEx;
                            }

                             MATCHT(35, &FOLLOW_35_in_numeric472);
                            if  (HASEXCEPTION())
                            {
                                goto rulenumericEx;
                            }

                            // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:131:33: ( DIGIT )+
                            {
                                int cnt29=0;

                                for (;;)
                                {
                                    int alt29=2;
                                switch ( LA(1) )
                                {
                                case DIGIT:
                                        {
                                                alt29=1;
                                        }
                                    break;

                                }

                                switch (alt29)
                                {
                                    case 1:
                                        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:131:34: DIGIT
                                        {
                                             MATCHT(DIGIT, &FOLLOW_DIGIT_in_numeric475);
                                            if  (HASEXCEPTION())
                                            {
                                                goto rulenumericEx;
                                            }


                                        }
                                        break;

                                    default:

                                        if ( cnt29 >= 1 )
                                        {
                                            goto loop29;
                                        }
                                        /* mismatchedSetEx()
                                         */
                                        CONSTRUCTEX();
                                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                                        goto rulenumericEx;
                                }
                                cnt29++;
                                }
                                loop29: ;       /* Jump to here if this rule does not match */
                            }
                             MATCHT(36, &FOLLOW_36_in_numeric479);
                            if  (HASEXCEPTION())
                            {
                                goto rulenumericEx;
                            }


                        }


                    }
                    break;

            }
        }
    }


    // This is where rules clean up and exit
    //
    goto rulenumericEx; /* Prevent compiler warnings */
    rulenumericEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end numeric */

/**
 * $ANTLR start char_string
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:133:1: char_string : CHAR_STRING ;
 */
static void
char_string(pcifParser ctx)
{
    /* Initialize rule variables
     */


    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:134:2: ( CHAR_STRING )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:134:4: CHAR_STRING
        {
             MATCHT(CHAR_STRING, &FOLLOW_CHAR_STRING_in_char_string491);
            if  (HASEXCEPTION())
            {
                goto rulechar_stringEx;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto rulechar_stringEx; /* Prevent compiler warnings */
    rulechar_stringEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end char_string */

/**
 * $ANTLR start text_field
 * C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:136:1: text_field : SEMI_COLON_TEXT_FIELD ;
 */
static void
text_field(pcifParser ctx)
{
    /* Initialize rule variables
     */


    {
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:137:2: ( SEMI_COLON_TEXT_FIELD )
        // C:\\cctbx_svn\\cctbx_project\\iotbx\\cif\\cif.g:137:4: SEMI_COLON_TEXT_FIELD
        {
             MATCHT(SEMI_COLON_TEXT_FIELD, &FOLLOW_SEMI_COLON_TEXT_FIELD_in_text_field501);
            if  (HASEXCEPTION())
            {
                goto ruletext_fieldEx;
            }


        }

    }


    // This is where rules clean up and exit
    //
    goto ruletext_fieldEx; /* Prevent compiler warnings */
    ruletext_fieldEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end text_field */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */

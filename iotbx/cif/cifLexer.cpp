/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : cif.g
 *     -                            On : 2011-01-30 15:57:13
 *     -                 for the lexer : cifLexerLexer *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "cifLexer.h"
/* ----------------------------------------- */


/** String literals used by cifLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR     lit_1[]  = { 0x0D, 0x0A,  ANTLR3_STRING_TERMINATOR};




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define         CTX     ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef  SCOPE_TYPE
#undef  SCOPE_STACK
#undef  SCOPE_TOP
#define SCOPE_TYPE(scope)   pcifLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pcifLexer_##scope##Stack
#define SCOPE_TOP(scope)    ctx->pcifLexer_##scope##Top
#define SCOPE_SIZE(scope)               ctx->pcifLexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)        (ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))


/* Macros for accessing things in a lexer
 */
#undef      LEXER
#undef      RECOGNIZER
#undef      RULEMEMO
#undef      GETCHARINDEX
#undef      GETLINE
#undef      GETCHARPOSITIONINLINE
#undef      EMIT
#undef      EMITNEW
#undef      MATCHC
#undef      MATCHS
#undef      MATCHRANGE
#undef      LTOKEN
#undef      HASFAILED
#undef      FAILEDFLAG
#undef      INPUT
#undef      STRSTREAM
#undef      LA
#undef      HASEXCEPTION
#undef      EXCEPTION
#undef      CONSTRUCTEX
#undef      CONSUME
#undef      LRECOVER
#undef      MARK
#undef      REWIND
#undef      REWINDLAST
#undef      BACKTRACKING
#undef          MATCHANY
#undef          MEMOIZE
#undef          HAVEPARSEDRULE
#undef          GETTEXT
#undef          INDEX
#undef          SEEK
#undef          PUSHSTREAM
#undef          POPSTREAM
#undef          SETTEXT
#undef          SETTEXT8

#define     LEXER                                       ctx->pLexer
#define     RECOGNIZER                      LEXER->rec
#define         LEXSTATE                                RECOGNIZER->state
#define         TOKSOURCE                               LEXSTATE->tokSource
#define     GETCHARINDEX()                      LEXER->getCharIndex(LEXER)
#define     GETLINE()                           LEXER->getLine(LEXER)
#define     GETTEXT()                           LEXER->getText(LEXER)
#define     GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define     EMIT()                                      LEXSTATE->type = _type; LEXER->emit(LEXER)
#define     EMITNEW(t)                          LEXER->emitNew(LEXER, t)
#define     MATCHC(c)                           LEXER->matchc(LEXER, c)
#define     MATCHS(s)                           LEXER->matchs(LEXER, s)
#define     MATCHRANGE(c1,c2)       LEXER->matchRange(LEXER, c1, c2)
#define     MATCHANY()                          LEXER->matchAny(LEXER)
#define     LTOKEN                              LEXSTATE->token
#define     HASFAILED()                         (LEXSTATE->failed == ANTLR3_TRUE)
#define     BACKTRACKING                        LEXSTATE->backtracking
#define     FAILEDFLAG                          LEXSTATE->failed
#define     INPUT                                       LEXER->input
#define     STRSTREAM                           INPUT
#define         ISTREAM                                 INPUT->istream
#define         INDEX()                                 ISTREAM->index(ISTREAM)
#define         SEEK(n)                                 ISTREAM->seek(ISTREAM, n)
#define     EOF_TOKEN                           &(LEXSTATE->tokSource->eofToken)
#define     HASEXCEPTION()                      (LEXSTATE->error == ANTLR3_TRUE)
#define     EXCEPTION                           LEXSTATE->exception
#define     CONSTRUCTEX()                       RECOGNIZER->exConstruct(RECOGNIZER)
#define     LRECOVER()                          LEXER->recover(LEXER)
#define     MARK()                                      ISTREAM->mark(ISTREAM)
#define     REWIND(m)                           ISTREAM->rewind(ISTREAM, m)
#define     REWINDLAST()                        ISTREAM->rewindLast(ISTREAM)
#define         MEMOIZE(ri,si)                  RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define         HAVEPARSEDRULE(r)               RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define         PUSHSTREAM(str)                 LEXER->pushCharStream(LEXER, str)
#define         POPSTREAM()                             LEXER->popCharStream(LEXER)
#define         SETTEXT(str)                    LEXSTATE->text = str
#define         SKIP()                                  LEXSTATE->token = &(TOKSOURCE->skipToken)
#define         USER1                                   LEXSTATE->user1
#define         USER2                                   LEXSTATE->user2
#define         USER3                                   LEXSTATE->user3
#define         CUSTOM                                  LEXSTATE->custom
#define         RULEMEMO                                LEXSTATE->ruleMemo
#define         DBG                                             RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or 16 bit input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if     defined(ANTLR3_INLINE_INPUT_ASCII) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef ANTLR3_INLINE_INPUT_ASCII

/* 8 bit "ASCII" (actually any 8 bit character set) */

#  define           NEXTCHAR                    ((pANTLR3_UINT8)(INPUT->nextChar))
#  define           DATAP                               ((pANTLR3_UINT8)(INPUT->data))

# else

#  define           NEXTCHAR                    ((pANTLR3_UINT16)(INPUT->nextChar))
#  define           DATAP                               ((pANTLR3_UINT16)(INPUT->data))

# endif

# define            LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define            CONSUME()                                                                                   \
{                                                                                                                                       \
    if  (NEXTCHAR < (DATAP + INPUT->sizeBuf))                                           \
    {                                                                                                                           \
                INPUT->charPositionInLine++;                                                            \
                if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)           \
                {                                                                                                                       \
                        INPUT->line++;                                                                                  \
                        INPUT->charPositionInLine       = 0;                                            \
                        INPUT->currentLine              = (void *)(NEXTCHAR + 1);               \
                }                                                                                                                       \
                INPUT->nextChar = (void *)(NEXTCHAR + 1);                                       \
    }                                                                                                                           \
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define     CONSUME()                           INPUT->istream->consume(INPUT->istream)
#define     LA(n)                                       INPUT->istream->_LA(INPUT->istream, n)

#endif
#define         TOKTEXT(tok, txt)                               tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define     UP      ANTLR3_TOKEN_UP
#define     DOWN    ANTLR3_TOKEN_DOWN
#define     EOR     ANTLR3_TOKEN_EOR
#define     INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE  void      mT__33    (pcifLexer ctx);
static ANTLR3_INLINE  void      mT__34    (pcifLexer ctx);
static ANTLR3_INLINE  void      mT__35    (pcifLexer ctx);
static ANTLR3_INLINE  void      mT__36    (pcifLexer ctx);
static ANTLR3_INLINE  void      mT__37    (pcifLexer ctx);
static ANTLR3_INLINE  void      mT__38    (pcifLexer ctx);
static ANTLR3_INLINE  void      mT__39    (pcifLexer ctx);
static ANTLR3_INLINE  void      mEOL    (pcifLexer ctx);
static ANTLR3_INLINE  void      mDOUBLE_QUOTE    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSINGLE_QUOTE    (pcifLexer ctx);
static ANTLR3_INLINE  void      mORDINARY_CHAR    (pcifLexer ctx);
static ANTLR3_INLINE  void      mNON_BLANK_CHAR_    (pcifLexer ctx);
static ANTLR3_INLINE  void      mTEXT_LEAD_CHAR    (pcifLexer ctx);
static ANTLR3_INLINE  void      mANY_PRINT_CHAR    (pcifLexer ctx);
static ANTLR3_INLINE  void      mTAG    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSEMI_COLON_TEXT_FIELD    (pcifLexer ctx);
static ANTLR3_INLINE  void      mDATA_    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSAVE_    (pcifLexer ctx);
static ANTLR3_INLINE  void      mLOOP_    (pcifLexer ctx);
static ANTLR3_INLINE  void      mGLOBAL_    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSTOP_    (pcifLexer ctx);
static ANTLR3_INLINE  void      mDATA_BLOCK_HEADING    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSAVE_FRAME_HEADING    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSAVE    (pcifLexer ctx);
static ANTLR3_INLINE  void      mSINGLE_QUOTED_STRING    (pcifLexer ctx);
static ANTLR3_INLINE  void      mDOUBLE_QUOTED_STRING    (pcifLexer ctx);
static ANTLR3_INLINE  void      mDIGIT    (pcifLexer ctx);
static ANTLR3_INLINE  void      mEXPONENT    (pcifLexer ctx);
static ANTLR3_INLINE  void      mINTEGER    (pcifLexer ctx);
static ANTLR3_INLINE  void      mFLOAT    (pcifLexer ctx);
static ANTLR3_INLINE  void      mUNSIGNED_INTEGER    (pcifLexer ctx);
static ANTLR3_INLINE  void      mUNQUOTED_STRING    (pcifLexer ctx);
static ANTLR3_INLINE  void      mCHAR_STRING    (pcifLexer ctx);
static ANTLR3_INLINE  void      mCOMMENTS    (pcifLexer ctx);
static ANTLR3_INLINE  void      mNON_BLANK_CHAR    (pcifLexer ctx);
static ANTLR3_INLINE  void      mWHITESPACE    (pcifLexer ctx);
static ANTLR3_INLINE  void      mTokens    (pcifLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN     synpred1_cif    (pcifLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN     synpred2_cif    (pcifLexer ctx);
static void     cifLexerFree(pcifLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
cifLexerFree  (pcifLexer ctx)
{
    LEXER->free(LEXER);

    ANTLR3_FREE(ctx);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "cif.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
        return fileName;
}

/** \brief Create a new lexer called cifLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pcifLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pcifLexer cifLexerNew
(pANTLR3_INPUT_STREAM instream)
{
        // See if we can create a new lexer with the standard constructor
        //
        return cifLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called cifLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pcifLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pcifLexer cifLexerNewSSD
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pcifLexer ctx; // Context structure we will build and return

    ctx = (pcifLexer) ANTLR3_CALLOC(1, sizeof(cifLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in cifLexer.h here so you can get a sense
     * of what goes where.
     */

    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer = antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Check that we allocated the memory correctly
     */
    if  (ctx->pLexer == NULL)
    {
                ANTLR3_FREE(ctx);
                return  NULL;
    }
    /* Install the implementation of our cifLexer interface
     */
    ctx->mT__33 = mT__33;
    ctx->mT__34 = mT__34;
    ctx->mT__35 = mT__35;
    ctx->mT__36 = mT__36;
    ctx->mT__37 = mT__37;
    ctx->mT__38 = mT__38;
    ctx->mT__39 = mT__39;
    ctx->mEOL   = mEOL;
    ctx->mDOUBLE_QUOTE  = mDOUBLE_QUOTE;
    ctx->mSINGLE_QUOTE  = mSINGLE_QUOTE;
    ctx->mORDINARY_CHAR = mORDINARY_CHAR;
    ctx->mNON_BLANK_CHAR_       = mNON_BLANK_CHAR_;
    ctx->mTEXT_LEAD_CHAR        = mTEXT_LEAD_CHAR;
    ctx->mANY_PRINT_CHAR        = mANY_PRINT_CHAR;
    ctx->mTAG   = mTAG;
    ctx->mSEMI_COLON_TEXT_FIELD = mSEMI_COLON_TEXT_FIELD;
    ctx->mDATA_ = mDATA_;
    ctx->mSAVE_ = mSAVE_;
    ctx->mLOOP_ = mLOOP_;
    ctx->mGLOBAL_       = mGLOBAL_;
    ctx->mSTOP_ = mSTOP_;
    ctx->mDATA_BLOCK_HEADING    = mDATA_BLOCK_HEADING;
    ctx->mSAVE_FRAME_HEADING    = mSAVE_FRAME_HEADING;
    ctx->mSAVE  = mSAVE;
    ctx->mSINGLE_QUOTED_STRING  = mSINGLE_QUOTED_STRING;
    ctx->mDOUBLE_QUOTED_STRING  = mDOUBLE_QUOTED_STRING;
    ctx->mDIGIT = mDIGIT;
    ctx->mEXPONENT      = mEXPONENT;
    ctx->mINTEGER       = mINTEGER;
    ctx->mFLOAT = mFLOAT;
    ctx->mUNSIGNED_INTEGER      = mUNSIGNED_INTEGER;
    ctx->mUNQUOTED_STRING       = mUNQUOTED_STRING;
    ctx->mCHAR_STRING   = mCHAR_STRING;
    ctx->mCOMMENTS      = mCOMMENTS;
    ctx->mNON_BLANK_CHAR        = mNON_BLANK_CHAR;
    ctx->mWHITESPACE    = mWHITESPACE;
    ctx->mTokens        = mTokens;

    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx        = ctx;

    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);

    ctx->getGrammarFileName     = getGrammarFileName;
    ctx->free           = cifLexerFree;




           LEXER->super = (void *)ctx;


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    291:1: FLOAT : ( INTEGER EXPONENT | ( ( '+' | '-' )? ( ( DIGIT )* '.' ( DIGIT )+ ) | ( DIGIT )+ '.' ) ( EXPONENT )? );
 */
static const ANTLR3_INT32 dfa25_eot[6] =
    {
        -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa25_eof[6] =
    {
        -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa25_min[6] =
    {
        43, 46, 46, -1, 46, -1
    };
static const ANTLR3_INT32 dfa25_max[6] =
    {
        57, 57, 101, -1, 101, -1
    };
static const ANTLR3_INT32 dfa25_accept[6] =
    {
        -1, -1, -1, 2, -1, 1
    };
static const ANTLR3_INT32 dfa25_special[6] =
    {
        -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa25_T_empty       NULL

static const ANTLR3_INT32 dfa25_T0[] =
    {
        1, -1, 1, 3, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
    };static const ANTLR3_INT32 dfa25_T1[] =
    {
        3, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5
    };static const ANTLR3_INT32 dfa25_T2[] =
    {
        3, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5
    };static const ANTLR3_INT32 dfa25_T3[] =
    {
        3, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa25_transitions[] =
{
    dfa25_T0, dfa25_T3, dfa25_T2, dfa25_T_empty, dfa25_T1, dfa25_T_empty
};


/* Declare tracking structure for Cyclic DFA 25
 */
static
ANTLR3_CYCLIC_DFA cdfa25
    =   {
            25,             /* Decision number of this dfa          */
            /* Which decision this represents:   */
            (const pANTLR3_UCHAR)"291:1: FLOAT : ( INTEGER EXPONENT | ( ( '+' | '-' )? ( ( DIGIT )* '.' ( DIGIT )+ ) | ( DIGIT )+ '.' ) ( EXPONENT )? );",
            (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,        /* Default special state transition function    */
            antlr3dfaspecialTransition,         /* DFA specialTransition is currently just a default function in the runtime */
            antlr3dfapredict,                   /* DFA simulator function is in the runtime */
            dfa25_eot,      /* EOT table                            */
            dfa25_eof,      /* EOF table                            */
            dfa25_min,      /* Minimum tokens for each state    */
            dfa25_max,      /* Maximum tokens for each state    */
            dfa25_accept,       /* Accept table                     */
            dfa25_special,      /* Special transition states        */
            dfa25_transitions   /* Table of transition tables       */

        };
/* End of Cyclic DFA 25
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    292:24: ( ( '+' | '-' )? ( ( DIGIT )* '.' ( DIGIT )+ ) | ( DIGIT )+ '.' )
 */
static const ANTLR3_INT32 dfa23_eot[5] =
    {
        -1, -1, -1, 4, -1
    };
static const ANTLR3_INT32 dfa23_eof[5] =
    {
        -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa23_min[5] =
    {
        43, -1, 46, 48, -1
    };
static const ANTLR3_INT32 dfa23_max[5] =
    {
        57, -1, 57, 57, -1
    };
static const ANTLR3_INT32 dfa23_accept[5] =
    {
        -1, 1, -1, -1, 2
    };
static const ANTLR3_INT32 dfa23_special[5] =
    {
        -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa23_T_empty       NULL

static const ANTLR3_INT32 dfa23_T0[] =
    {
        3, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
    };static const ANTLR3_INT32 dfa23_T1[] =
    {
        1, -1, 1, 1, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
    };static const ANTLR3_INT32 dfa23_T2[] =
    {
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa23_transitions[] =
{
    dfa23_T1, dfa23_T_empty, dfa23_T0, dfa23_T2, dfa23_T_empty
};


/* Declare tracking structure for Cyclic DFA 23
 */
static
ANTLR3_CYCLIC_DFA cdfa23
    =   {
            23,             /* Decision number of this dfa          */
            /* Which decision this represents:   */
            (const pANTLR3_UCHAR)"292:24: ( ( '+' | '-' )? ( ( DIGIT )* '.' ( DIGIT )+ ) | ( DIGIT )+ '.' )",
            (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,        /* Default special state transition function    */
            antlr3dfaspecialTransition,         /* DFA specialTransition is currently just a default function in the runtime */
            antlr3dfapredict,                   /* DFA simulator function is in the runtime */
            dfa23_eot,      /* EOT table                            */
            dfa23_eof,      /* EOF table                            */
            dfa23_min,      /* Minimum tokens for each state    */
            dfa23_max,      /* Maximum tokens for each state    */
            dfa23_accept,       /* Accept table                     */
            dfa23_special,      /* Special transition states        */
            dfa23_transitions   /* Table of transition tables       */

        };
/* End of Cyclic DFA 23
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( T__33 | T__34 | T__35 | T__36 | T__37 | T__38 | T__39 | TAG | SEMI_COLON_TEXT_FIELD | LOOP_ | GLOBAL_ | STOP_ | DATA_BLOCK_HEADING | SAVE_FRAME_HEADING | SAVE | FLOAT | UNSIGNED_INTEGER | CHAR_STRING | COMMENTS | NON_BLANK_CHAR | WHITESPACE );
 */
static const ANTLR3_INT32 dfa34_eot[221] =
    {
        -1, -1, 44, 47, 50, 51, 52, 53, 42, 46, 46, 46, 46, 46, 101, 42, 42, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46, 46, 46, 46, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 107, -1, -1, 46, 46, -1, -1, -1, -1,
        -1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, -1, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, -1, 107, 101, 46, 46, -1, -1,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 107, 46, 46, 107, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 142, 46, 46, 145, 146, 46, -1,
        46, 46, -1, -1, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218,
        218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218,
        218, 218, 218, 218, 218, 218, 218, 218, 218, 219, 219, 219, 219, 219, 219,
        219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219,
        219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 220,
        -1, -1, -1
    };
static const ANTLR3_INT32 dfa34_eof[221] =
    {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa34_min[221] =
    {
        9, -1, 33, 33, 33, 33, 33, 33, 33, 9, 79, 76, 65, 65, 33, 9, 9, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 79, 76, 65, 65, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 33, -1, -1, 46, 48, -1, -1, -1, -1, -1,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, -1, 9, 9, 9, 79, 79, 79, 79, 79, 86, 79, 86, 84,
        84, -1, 33, 33, 43, 43, -1, -1, 43, 43, 80, 80, 66, 66, 80, 80, 69, 69,
        65, 65, 48, 33, 48, 48, 33, 48, 95, 95, 65, 65, 95, 95, 95, 95, 95, 95,
        33, 76, 76, 33, 33, 33, -1, 95, 95, -1, -1, 33, 33, 33, 33, 33, 33, 33,
        33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
        33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
        33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
        33, 33, 33, 33, 33, 33, 33, 33, 33, 33, -1, -1, -1
    };
static const ANTLR3_INT32 dfa34_max[221] =
    {
        126, -1, 126, 126, 126, 126, 126, 126, 126, 126, 111, 108, 116, 97, 126,
        126, 126, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 111, 108, 116, 97,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 126, -1, -1, 101, 57,
        -1, -1, -1, -1, -1, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
        126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
        126, 126, 126, 126, 126, 126, -1, 126, 126, 126, 111, 111, 111, 111, 111,
        118, 111, 118, 116, 116, -1, 126, 126, 57, 57, -1, -1, 57, 57, 112, 112,
        98, 98, 112, 112, 101, 101, 97, 97, 57, 126, 57, 57, 126, 57, 95, 95, 97,
        97, 95, 95, 95, 95, 95, 95, 126, 108, 108, 126, 126, 126, -1, 95, 95, -1,
        -1, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
        126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
        126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
        126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
        126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, -1, -1, -1
    };
static const ANTLR3_INT32 dfa34_accept[221] =
    {
        -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18,
        18, 18, 18, 18, 18, 18, 18, 18, 18, 18, -1, -1, -1, -1, 18, 18, 18, 18,
        18, 18, 18, 18, 18, 19, 20, 21, 2, -1, 18, 3, -1, -1, 4, 5, 6, 7, 8, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, 19, 16, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, 12,
        15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        14, 13, 11
    };
static const ANTLR3_INT32 dfa34_special[221] =
    {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa34_T_empty       NULL

static const ANTLR3_INT32 dfa34_T0[] =
    {
        147, 174, 176, 177, 148, 149, 175, 150, 151, 152, 153, 154, 155, 156,
        157, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 159, 181, 160, 161,
        162, 163, 164, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165,
        165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 179,
        167, 180, 168, 178, 169, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166,
        166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166,
        166, 170, 171, 172, 173
    };static const ANTLR3_INT32 dfa34_T1[] =
    {
        54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
        54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
        54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
        54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
        54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
        54, 54, 54, 54
    };static const ANTLR3_INT32 dfa34_T2[] =
    {
        45, 45, 45, 45, 45, 45, 45, 45, 45, 45
    };static const ANTLR3_INT32 dfa34_T3[] =
    {
        49, -1, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 105
    };static const ANTLR3_INT32 dfa34_T4[] =
    {
        87, 87, -1, -1, 87, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 87, 55, 90, 82, 83, 56, 57, 89, 58, 59, 60, 61, 62,
        63, 64, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 88, 68, 69, 70,
        71, 72, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
        73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 85, 75, 86, 76, 84, 77, 74, 74,
        74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
        74, 74, 74, 74, 74, 74, 78, 79, 80, 81
    };static const ANTLR3_INT32 dfa34_T5[] =
    {
        182, 209, 211, 212, 183, 184, 210, 185, 186, 187, 188, 189, 190, 191,
        192, 193, 193, 193, 193, 193, 193, 193, 193, 193, 193, 194, 216, 195, 196,
        197, 198, 199, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200,
        200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 214,
        202, 215, 203, 213, 204, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201,
        201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201,
        201, 205, 206, 207, 208
    };static const ANTLR3_INT32 dfa34_T6[] =
    {
        116, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 117
    };static const ANTLR3_INT32 dfa34_T7[] =
    {
        46, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46
    };static const ANTLR3_INT32 dfa34_T8[] =
    {
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 49, 46, 48, 48, 48,
        48, 48, 48, 48, 48, 48, 48, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46
    };static const ANTLR3_INT32 dfa34_T9[] =
    {
        96, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 98, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97
    };static const ANTLR3_INT32 dfa34_T10[] =
    {
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 102, 46, 103, 103,
        103, 103, 103, 103, 103, 103, 103, 103, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 104, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 105,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46
    };static const ANTLR3_INT32 dfa34_T11[] =
    {
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 45, 45, 45,
        45, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46
    };static const ANTLR3_INT32 dfa34_T12[] =
    {
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 45, 45, 45,
        45, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        108, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 109, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46
    };static const ANTLR3_INT32 dfa34_T13[] =
    {
        134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 135
    };static const ANTLR3_INT32 dfa34_T14[] =
    {
        118, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 119
    };static const ANTLR3_INT32 dfa34_T15[] =
    {
        141
    };static const ANTLR3_INT32 dfa34_T16[] =
    {
        136
    };static const ANTLR3_INT32 dfa34_T17[] =
    {
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46
    };static const ANTLR3_INT32 dfa34_T18[] =
    {
        112, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 113
    };static const ANTLR3_INT32 dfa34_T19[] =
    {
        110, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 111
    };static const ANTLR3_INT32 dfa34_T20[] =
    {
        126, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 127
    };static const ANTLR3_INT32 dfa34_T21[] =
    {
        217
    };static const ANTLR3_INT32 dfa34_T22[] =
    {
        114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 115
    };static const ANTLR3_INT32 dfa34_T23[] =
    {
        137, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 138
    };static const ANTLR3_INT32 dfa34_T24[] =
    {
        128, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 129
    };static const ANTLR3_INT32 dfa34_T25[] =
    {
        143, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 144
    };static const ANTLR3_INT32 dfa34_T26[] =
    {
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 124, 124,
        124, 124, 124, 124, 124, 124, 124, 124, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46
    };static const ANTLR3_INT32 dfa34_T27[] =
    {
        130, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 131
    };static const ANTLR3_INT32 dfa34_T28[] =
    {
        139
    };static const ANTLR3_INT32 dfa34_T29[] =
    {
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 121, 121,
        121, 121, 121, 121, 121, 121, 121, 121, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
        46, 46, 46, 46, 46, 46, 46
    };static const ANTLR3_INT32 dfa34_T30[] =
    {
        43, 43, -1, 43, 43, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1,
        -1, -1, -1, -1, -1, 43, 17, 16, 41, 42, 18, 19, 15, 6, 7, 20, 5, 21, 4,
        2, 22, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 23, 9, 24, 25, 26, 3, 27,
        32, 32, 32, 13, 32, 32, 11, 32, 32, 32, 32, 10, 32, 32, 32, 32, 32, 32,
        12, 32, 32, 32, 32, 32, 32, 32, 42, 34, 42, 35, 8, 36, 33, 33, 33, 31,
        33, 33, 29, 33, 33, 33, 33, 28, 33, 33, 33, 33, 33, 33, 30, 33, 33, 33,
        33, 33, 33, 33, 37, 38, 39, 40
    };static const ANTLR3_INT32 dfa34_T31[] =
    {
        120, -1, 122, -1, -1, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121
    };static const ANTLR3_INT32 dfa34_T32[] =
    {
        123, -1, 125, -1, -1, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124
    };static const ANTLR3_INT32 dfa34_T33[] =
    {
        91, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92
    };static const ANTLR3_INT32 dfa34_T34[] =
    {
        121, 121, 121, 121, 121, 121, 121, 121, 121, 121
    };static const ANTLR3_INT32 dfa34_T35[] =
    {
        124, 124, 124, 124, 124, 124, 124, 124, 124, 124
    };static const ANTLR3_INT32 dfa34_T36[] =
    {
        93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94
    };static const ANTLR3_INT32 dfa34_T37[] =
    {
        99, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 100
    };static const ANTLR3_INT32 dfa34_T38[] =
    {
        140
    };static const ANTLR3_INT32 dfa34_T39[] =
    {
        132, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 133
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa34_transitions[] =
{
    dfa34_T30, dfa34_T_empty, dfa34_T11, dfa34_T17, dfa34_T8, dfa34_T8,
    dfa34_T17, dfa34_T17, dfa34_T1, dfa34_T4, dfa34_T33, dfa34_T36, dfa34_T9,
    dfa34_T37, dfa34_T10, dfa34_T7, dfa34_T7, dfa34_T_empty, dfa34_T_empty,
    dfa34_T_empty, dfa34_T_empty, dfa34_T_empty, dfa34_T_empty, dfa34_T_empty,
    dfa34_T_empty, dfa34_T_empty, dfa34_T_empty, dfa34_T_empty, dfa34_T33,
    dfa34_T36, dfa34_T9, dfa34_T37, dfa34_T_empty, dfa34_T_empty, dfa34_T_empty,
    dfa34_T_empty, dfa34_T_empty, dfa34_T_empty, dfa34_T_empty, dfa34_T_empty,
    dfa34_T_empty, dfa34_T_empty, dfa34_T_empty, dfa34_T_empty, dfa34_T_empty,
    dfa34_T12, dfa34_T_empty, dfa34_T_empty, dfa34_T3, dfa34_T2, dfa34_T_empty,
    dfa34_T_empty, dfa34_T_empty, dfa34_T_empty, dfa34_T_empty, dfa34_T4,
    dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4,
    dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4,
    dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4,
    dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T4,
    dfa34_T4, dfa34_T4, dfa34_T4, dfa34_T_empty, dfa34_T4, dfa34_T4, dfa34_T4,
    dfa34_T19, dfa34_T19, dfa34_T18, dfa34_T18, dfa34_T22, dfa34_T6, dfa34_T22,
    dfa34_T6, dfa34_T14, dfa34_T14, dfa34_T_empty, dfa34_T12, dfa34_T10,
    dfa34_T31, dfa34_T31, dfa34_T_empty, dfa34_T_empty, dfa34_T32, dfa34_T32,
    dfa34_T20, dfa34_T20, dfa34_T24, dfa34_T24, dfa34_T27, dfa34_T27, dfa34_T39,
    dfa34_T39, dfa34_T13, dfa34_T13, dfa34_T34, dfa34_T29, dfa34_T34, dfa34_T35,
    dfa34_T26, dfa34_T35, dfa34_T16, dfa34_T16, dfa34_T23, dfa34_T23, dfa34_T28,
    dfa34_T28, dfa34_T38, dfa34_T38, dfa34_T15, dfa34_T15, dfa34_T17, dfa34_T25,
    dfa34_T25, dfa34_T17, dfa34_T0, dfa34_T5, dfa34_T_empty, dfa34_T21,
    dfa34_T21, dfa34_T_empty, dfa34_T_empty, dfa34_T0, dfa34_T0, dfa34_T0,
    dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0,
    dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0,
    dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0,
    dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0,
    dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T5, dfa34_T5, dfa34_T5,
    dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5,
    dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5,
    dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5,
    dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5,
    dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T5, dfa34_T17, dfa34_T_empty, dfa34_T_empty,
    dfa34_T_empty
};


/* Declare tracking structure for Cyclic DFA 34
 */
static
ANTLR3_CYCLIC_DFA cdfa34
    =   {
            34,             /* Decision number of this dfa          */
            /* Which decision this represents:   */
            (const pANTLR3_UCHAR)"1:1: Tokens : ( T__33 | T__34 | T__35 | T__36 | T__37 | T__38 | T__39 | TAG | SEMI_COLON_TEXT_FIELD | LOOP_ | GLOBAL_ | STOP_ | DATA_BLOCK_HEADING | SAVE_FRAME_HEADING | SAVE | FLOAT | UNSIGNED_INTEGER | CHAR_STRING | COMMENTS | NON_BLANK_CHAR | WHITESPACE );",
            (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,        /* Default special state transition function    */
            antlr3dfaspecialTransition,         /* DFA specialTransition is currently just a default function in the runtime */
            antlr3dfapredict,                   /* DFA simulator function is in the runtime */
            dfa34_eot,      /* EOT table                            */
            dfa34_eof,      /* EOF table                            */
            dfa34_min,      /* Minimum tokens for each state    */
            dfa34_max,      /* Maximum tokens for each state    */
            dfa34_accept,       /* Accept table                     */
            dfa34_special,      /* Special transition states        */
            dfa34_transitions   /* Table of transition tables       */

        };
/* End of Cyclic DFA 34
 * ---------------------
 */
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 28:7: ( '\\u001a' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__33
 *
 * Looks to match the characters the constitute the token T__33
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__33(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = T__33;


    // cif.g:28:7: ( '\\u001a' )
    // cif.g:28:9: '\\u001a'
    {
        MATCHC(0x001a);
        if  (HASEXCEPTION())
        {
            goto ruleT__33Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__33Ex; /* Prevent compiler warnings */
    ruleT__33Ex: ;

}
// $ANTLR end T__33

//   Comes from: 29:7: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__34
 *
 * Looks to match the characters the constitute the token T__34
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__34(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = T__34;


    // cif.g:29:7: ( '.' )
    // cif.g:29:9: '.'
    {
        MATCHC('.');
        if  (HASEXCEPTION())
        {
            goto ruleT__34Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__34Ex; /* Prevent compiler warnings */
    ruleT__34Ex: ;

}
// $ANTLR end T__34

//   Comes from: 30:7: ( '?' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__35
 *
 * Looks to match the characters the constitute the token T__35
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__35(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = T__35;


    // cif.g:30:7: ( '?' )
    // cif.g:30:9: '?'
    {
        MATCHC('?');
        if  (HASEXCEPTION())
        {
            goto ruleT__35Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__35Ex; /* Prevent compiler warnings */
    ruleT__35Ex: ;

}
// $ANTLR end T__35

//   Comes from: 31:7: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__36
 *
 * Looks to match the characters the constitute the token T__36
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__36(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = T__36;


    // cif.g:31:7: ( '-' )
    // cif.g:31:9: '-'
    {
        MATCHC('-');
        if  (HASEXCEPTION())
        {
            goto ruleT__36Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__36Ex; /* Prevent compiler warnings */
    ruleT__36Ex: ;

}
// $ANTLR end T__36

//   Comes from: 32:7: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__37
 *
 * Looks to match the characters the constitute the token T__37
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__37(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = T__37;


    // cif.g:32:7: ( '+' )
    // cif.g:32:9: '+'
    {
        MATCHC('+');
        if  (HASEXCEPTION())
        {
            goto ruleT__37Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__37Ex; /* Prevent compiler warnings */
    ruleT__37Ex: ;

}
// $ANTLR end T__37

//   Comes from: 33:7: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__38
 *
 * Looks to match the characters the constitute the token T__38
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__38(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = T__38;


    // cif.g:33:7: ( '(' )
    // cif.g:33:9: '('
    {
        MATCHC('(');
        if  (HASEXCEPTION())
        {
            goto ruleT__38Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__38Ex; /* Prevent compiler warnings */
    ruleT__38Ex: ;

}
// $ANTLR end T__38

//   Comes from: 34:7: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__39
 *
 * Looks to match the characters the constitute the token T__39
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__39(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = T__39;


    // cif.g:34:7: ( ')' )
    // cif.g:34:9: ')'
    {
        MATCHC(')');
        if  (HASEXCEPTION())
        {
            goto ruleT__39Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__39Ex; /* Prevent compiler warnings */
    ruleT__39Ex: ;

}
// $ANTLR end T__39

//   Comes from: 197:2: ( ( '\\n' | '\\r' | '\\r\\n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EOL
 *
 * Looks to match the characters the constitute the token EOL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEOL(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // cif.g:197:2: ( ( '\\n' | '\\r' | '\\r\\n' ) )
    // cif.g:197:4: ( '\\n' | '\\r' | '\\r\\n' )
    {

        // cif.g:197:4: ( '\\n' | '\\r' | '\\r\\n' )
        {
            int alt1=3;
            switch ( LA(1) )
            {
            case '\n':
                {
                        alt1=1;
                }
                break;
            case '\r':
                {
                        switch ( LA(2) )
                        {
                        case '\n':
                                {
                                        alt1=3;
                                }
                            break;

                        default:
                            alt1=2;}

                }
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 1;
                EXCEPTION->state        = 0;


                goto ruleEOLEx;
            }

            switch (alt1)
            {
                case 1:
                    // cif.g:197:6: '\\n'
                    {
                        MATCHC('\n');
                        if  (HASEXCEPTION())
                        {
                            goto ruleEOLEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 2:
                    // cif.g:197:13: '\\r'
                    {
                        MATCHC('\r');
                        if  (HASEXCEPTION())
                        {
                            goto ruleEOLEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 3:
                    // cif.g:197:20: '\\r\\n'
                    {
                        MATCHS(lit_1);
                        if  (HASEXCEPTION())
                        {
                            goto ruleEOLEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }


                    }
                    break;

            }
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleEOLEx; /* Prevent compiler warnings */
    ruleEOLEx: ;

}
// $ANTLR end EOL

//   Comes from: 200:2: ( '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_QUOTE
 *
 * Looks to match the characters the constitute the token DOUBLE_QUOTE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOUBLE_QUOTE(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // cif.g:200:2: ( '\"' )
    // cif.g:200:4: '\"'
    {
        MATCHC('"');
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_QUOTEEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_QUOTEEx; /* Prevent compiler warnings */
    ruleDOUBLE_QUOTEEx: ;

}
// $ANTLR end DOUBLE_QUOTE

//   Comes from: 203:2: ( '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SINGLE_QUOTE
 *
 * Looks to match the characters the constitute the token SINGLE_QUOTE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSINGLE_QUOTE(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // cif.g:203:2: ( '\\'' )
    // cif.g:203:4: '\\''
    {
        MATCHC('\'');
        if  (HASEXCEPTION())
        {
            goto ruleSINGLE_QUOTEEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleSINGLE_QUOTEEx; /* Prevent compiler warnings */
    ruleSINGLE_QUOTEEx: ;

}
// $ANTLR end SINGLE_QUOTE

//   Comes from: 206:2: ( '!' | '%' | '&' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | ( '0' .. '9' ) | ':' | '<' | '=' | '>' | '?' | '@' | ( 'A' .. 'Z' ) | ( 'a' .. 'z' ) | '\\\\' | '^' | '`' | '{' | '|' | '}' | '~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ORDINARY_CHAR
 *
 * Looks to match the characters the constitute the token ORDINARY_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mORDINARY_CHAR(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    {
        //  cif.g:206:2: ( '!' | '%' | '&' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | ( '0' .. '9' ) | ':' | '<' | '=' | '>' | '?' | '@' | ( 'A' .. 'Z' ) | ( 'a' .. 'z' ) | '\\\\' | '^' | '`' | '{' | '|' | '}' | '~' )

        ANTLR3_UINT32 alt2;

        alt2=27;

        switch ( LA(1) )
        {
        case '!':
                {
                        alt2=1;
                }
            break;
        case '%':
                {
                        alt2=2;
                }
            break;
        case '&':
                {
                        alt2=3;
                }
            break;
        case '(':
                {
                        alt2=4;
                }
            break;
        case ')':
                {
                        alt2=5;
                }
            break;
        case '*':
                {
                        alt2=6;
                }
            break;
        case '+':
                {
                        alt2=7;
                }
            break;
        case ',':
                {
                        alt2=8;
                }
            break;
        case '-':
                {
                        alt2=9;
                }
            break;
        case '.':
                {
                        alt2=10;
                }
            break;
        case '/':
                {
                        alt2=11;
                }
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
                {
                        alt2=12;
                }
            break;
        case ':':
                {
                        alt2=13;
                }
            break;
        case '<':
                {
                        alt2=14;
                }
            break;
        case '=':
                {
                        alt2=15;
                }
            break;
        case '>':
                {
                        alt2=16;
                }
            break;
        case '?':
                {
                        alt2=17;
                }
            break;
        case '@':
                {
                        alt2=18;
                }
            break;
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
                {
                        alt2=19;
                }
            break;
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
                {
                        alt2=20;
                }
            break;
        case '\\':
                {
                        alt2=21;
                }
            break;
        case '^':
                {
                        alt2=22;
                }
            break;
        case '`':
                {
                        alt2=23;
                }
            break;
        case '{':
                {
                        alt2=24;
                }
            break;
        case '|':
                {
                        alt2=25;
                }
            break;
        case '}':
                {
                        alt2=26;
                }
            break;
        case '~':
                {
                        alt2=27;
                }
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 2;
            EXCEPTION->state        = 0;


            goto ruleORDINARY_CHAREx;
        }

        switch (alt2)
        {
        case 1:
            // cif.g:206:5: '!'
            {
                MATCHC('!');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 2:
            // cif.g:206:11: '%'
            {
                MATCHC('%');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 3:
            // cif.g:206:17: '&'
            {
                MATCHC('&');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 4:
            // cif.g:206:23: '('
            {
                MATCHC('(');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 5:
            // cif.g:206:29: ')'
            {
                MATCHC(')');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 6:
            // cif.g:206:35: '*'
            {
                MATCHC('*');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 7:
            // cif.g:206:41: '+'
            {
                MATCHC('+');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 8:
            // cif.g:206:47: ','
            {
                MATCHC(',');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 9:
            // cif.g:206:53: '-'
            {
                MATCHC('-');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 10:
            // cif.g:206:59: '.'
            {
                MATCHC('.');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 11:
            // cif.g:206:65: '/'
            {
                MATCHC('/');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 12:
            // cif.g:207:2: ( '0' .. '9' )
            {
                // cif.g:207:2: ( '0' .. '9' )
                // cif.g:207:4: '0' .. '9'
                {
                    MATCHRANGE('0', '9');
                    if  (HASEXCEPTION())
                    {
                        goto ruleORDINARY_CHAREx;
                    }
                    if (HASFAILED())
                    {
                        return ;
                    }

                }


            }
            break;
        case 13:
            // cif.g:207:18: ':'
            {
                MATCHC(':');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 14:
            // cif.g:207:24: '<'
            {
                MATCHC('<');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 15:
            // cif.g:207:30: '='
            {
                MATCHC('=');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 16:
            // cif.g:207:36: '>'
            {
                MATCHC('>');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 17:
            // cif.g:207:42: '?'
            {
                MATCHC('?');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 18:
            // cif.g:207:48: '@'
            {
                MATCHC('@');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 19:
            // cif.g:207:54: ( 'A' .. 'Z' )
            {
                // cif.g:207:54: ( 'A' .. 'Z' )
                // cif.g:207:55: 'A' .. 'Z'
                {
                    MATCHRANGE('A', 'Z');
                    if  (HASEXCEPTION())
                    {
                        goto ruleORDINARY_CHAREx;
                    }
                    if (HASFAILED())
                    {
                        return ;
                    }

                }


            }
            break;
        case 20:
            // cif.g:207:67: ( 'a' .. 'z' )
            {
                // cif.g:207:67: ( 'a' .. 'z' )
                // cif.g:207:68: 'a' .. 'z'
                {
                    MATCHRANGE('a', 'z');
                    if  (HASEXCEPTION())
                    {
                        goto ruleORDINARY_CHAREx;
                    }
                    if (HASFAILED())
                    {
                        return ;
                    }

                }


            }
            break;
        case 21:
            // cif.g:208:2: '\\\\'
            {
                MATCHC('\\');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 22:
            // cif.g:208:9: '^'
            {
                MATCHC('^');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 23:
            // cif.g:208:15: '`'
            {
                MATCHC('`');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 24:
            // cif.g:208:21: '{'
            {
                MATCHC('{');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 25:
            // cif.g:208:27: '|'
            {
                MATCHC('|');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 26:
            // cif.g:208:33: '}'
            {
                MATCHC('}');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 27:
            // cif.g:208:39: '~'
            {
                MATCHC('~');
                if  (HASEXCEPTION())
                {
                    goto ruleORDINARY_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleORDINARY_CHAREx; /* Prevent compiler warnings */
    ruleORDINARY_CHAREx: ;

}
// $ANTLR end ORDINARY_CHAR

//   Comes from: 213:2: ( ORDINARY_CHAR | DOUBLE_QUOTE | SINGLE_QUOTE | '#' | '$' | '_' | '[' | ']' | ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NON_BLANK_CHAR_
 *
 * Looks to match the characters the constitute the token NON_BLANK_CHAR_
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNON_BLANK_CHAR_(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    {
        //  cif.g:213:2: ( ORDINARY_CHAR | DOUBLE_QUOTE | SINGLE_QUOTE | '#' | '$' | '_' | '[' | ']' | ';' )

        ANTLR3_UINT32 alt3;

        alt3=9;

        switch ( LA(1) )
        {
        case '!':
        case '%':
        case '&':
        case '(':
        case ')':
        case '*':
        case '+':
        case ',':
        case '-':
        case '.':
        case '/':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case ':':
        case '<':
        case '=':
        case '>':
        case '?':
        case '@':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '\\':
        case '^':
        case '`':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
        case '{':
        case '|':
        case '}':
        case '~':
                {
                        alt3=1;
                }
            break;
        case '"':
                {
                        alt3=2;
                }
            break;
        case '\'':
                {
                        alt3=3;
                }
            break;
        case '#':
                {
                        alt3=4;
                }
            break;
        case '$':
                {
                        alt3=5;
                }
            break;
        case '_':
                {
                        alt3=6;
                }
            break;
        case '[':
                {
                        alt3=7;
                }
            break;
        case ']':
                {
                        alt3=8;
                }
            break;
        case ';':
                {
                        alt3=9;
                }
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 3;
            EXCEPTION->state        = 0;


            goto ruleNON_BLANK_CHAR_Ex;
        }

        switch (alt3)
        {
        case 1:
            // cif.g:213:4: ORDINARY_CHAR
            {
                /* 213:4: ORDINARY_CHAR */
                mORDINARY_CHAR(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 2:
            // cif.g:213:20: DOUBLE_QUOTE
            {
                /* 213:20: DOUBLE_QUOTE */
                mDOUBLE_QUOTE(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 3:
            // cif.g:213:35: SINGLE_QUOTE
            {
                /* 213:35: SINGLE_QUOTE */
                mSINGLE_QUOTE(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 4:
            // cif.g:213:50: '#'
            {
                MATCHC('#');
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 5:
            // cif.g:213:56: '$'
            {
                MATCHC('$');
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 6:
            // cif.g:213:62: '_'
            {
                MATCHC('_');
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 7:
            // cif.g:213:68: '['
            {
                MATCHC('[');
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 8:
            // cif.g:213:74: ']'
            {
                MATCHC(']');
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 9:
            // cif.g:213:80: ';'
            {
                MATCHC(';');
                if  (HASEXCEPTION())
                {
                    goto ruleNON_BLANK_CHAR_Ex;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleNON_BLANK_CHAR_Ex; /* Prevent compiler warnings */
    ruleNON_BLANK_CHAR_Ex: ;

}
// $ANTLR end NON_BLANK_CHAR_

//   Comes from: 216:2: ( ORDINARY_CHAR | DOUBLE_QUOTE | SINGLE_QUOTE | '#' | '$' | '_' | '[' | ']' | ' ' | '\\t' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TEXT_LEAD_CHAR
 *
 * Looks to match the characters the constitute the token TEXT_LEAD_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTEXT_LEAD_CHAR(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    {
        //  cif.g:216:2: ( ORDINARY_CHAR | DOUBLE_QUOTE | SINGLE_QUOTE | '#' | '$' | '_' | '[' | ']' | ' ' | '\\t' )

        ANTLR3_UINT32 alt4;

        alt4=10;

        switch ( LA(1) )
        {
        case '!':
        case '%':
        case '&':
        case '(':
        case ')':
        case '*':
        case '+':
        case ',':
        case '-':
        case '.':
        case '/':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case ':':
        case '<':
        case '=':
        case '>':
        case '?':
        case '@':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '\\':
        case '^':
        case '`':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
        case '{':
        case '|':
        case '}':
        case '~':
                {
                        alt4=1;
                }
            break;
        case '"':
                {
                        alt4=2;
                }
            break;
        case '\'':
                {
                        alt4=3;
                }
            break;
        case '#':
                {
                        alt4=4;
                }
            break;
        case '$':
                {
                        alt4=5;
                }
            break;
        case '_':
                {
                        alt4=6;
                }
            break;
        case '[':
                {
                        alt4=7;
                }
            break;
        case ']':
                {
                        alt4=8;
                }
            break;
        case ' ':
                {
                        alt4=9;
                }
            break;
        case '\t':
                {
                        alt4=10;
                }
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 4;
            EXCEPTION->state        = 0;


            goto ruleTEXT_LEAD_CHAREx;
        }

        switch (alt4)
        {
        case 1:
            // cif.g:216:4: ORDINARY_CHAR
            {
                /* 216:4: ORDINARY_CHAR */
                mORDINARY_CHAR(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 2:
            // cif.g:216:20: DOUBLE_QUOTE
            {
                /* 216:20: DOUBLE_QUOTE */
                mDOUBLE_QUOTE(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 3:
            // cif.g:216:35: SINGLE_QUOTE
            {
                /* 216:35: SINGLE_QUOTE */
                mSINGLE_QUOTE(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 4:
            // cif.g:216:50: '#'
            {
                MATCHC('#');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 5:
            // cif.g:216:56: '$'
            {
                MATCHC('$');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 6:
            // cif.g:216:62: '_'
            {
                MATCHC('_');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 7:
            // cif.g:216:68: '['
            {
                MATCHC('[');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 8:
            // cif.g:216:74: ']'
            {
                MATCHC(']');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 9:
            // cif.g:216:80: ' '
            {
                MATCHC(' ');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 10:
            // cif.g:216:86: '\\t'
            {
                MATCHC('\t');
                if  (HASEXCEPTION())
                {
                    goto ruleTEXT_LEAD_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleTEXT_LEAD_CHAREx; /* Prevent compiler warnings */
    ruleTEXT_LEAD_CHAREx: ;

}
// $ANTLR end TEXT_LEAD_CHAR

//   Comes from: 219:2: ( ORDINARY_CHAR | '#' | '$' | '_' | '[' | ']' | ' ' | '\\t' | ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ANY_PRINT_CHAR
 *
 * Looks to match the characters the constitute the token ANY_PRINT_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mANY_PRINT_CHAR(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    {
        //  cif.g:219:2: ( ORDINARY_CHAR | '#' | '$' | '_' | '[' | ']' | ' ' | '\\t' | ';' )

        ANTLR3_UINT32 alt5;

        alt5=9;

        switch ( LA(1) )
        {
        case '!':
        case '%':
        case '&':
        case '(':
        case ')':
        case '*':
        case '+':
        case ',':
        case '-':
        case '.':
        case '/':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case ':':
        case '<':
        case '=':
        case '>':
        case '?':
        case '@':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '\\':
        case '^':
        case '`':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
        case '{':
        case '|':
        case '}':
        case '~':
                {
                        alt5=1;
                }
            break;
        case '#':
                {
                        alt5=2;
                }
            break;
        case '$':
                {
                        alt5=3;
                }
            break;
        case '_':
                {
                        alt5=4;
                }
            break;
        case '[':
                {
                        alt5=5;
                }
            break;
        case ']':
                {
                        alt5=6;
                }
            break;
        case ' ':
                {
                        alt5=7;
                }
            break;
        case '\t':
                {
                        alt5=8;
                }
            break;
        case ';':
                {
                        alt5=9;
                }
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 5;
            EXCEPTION->state        = 0;


            goto ruleANY_PRINT_CHAREx;
        }

        switch (alt5)
        {
        case 1:
            // cif.g:219:4: ORDINARY_CHAR
            {
                /* 219:4: ORDINARY_CHAR */
                mORDINARY_CHAR(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 2:
            // cif.g:219:20: '#'
            {
                MATCHC('#');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 3:
            // cif.g:219:26: '$'
            {
                MATCHC('$');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 4:
            // cif.g:219:32: '_'
            {
                MATCHC('_');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 5:
            // cif.g:219:38: '['
            {
                MATCHC('[');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 6:
            // cif.g:219:44: ']'
            {
                MATCHC(']');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 7:
            // cif.g:219:50: ' '
            {
                MATCHC(' ');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 8:
            // cif.g:219:56: '\\t'
            {
                MATCHC('\t');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 9:
            // cif.g:219:63: ';'
            {
                MATCHC(';');
                if  (HASEXCEPTION())
                {
                    goto ruleANY_PRINT_CHAREx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleANY_PRINT_CHAREx; /* Prevent compiler warnings */
    ruleANY_PRINT_CHAREx: ;

}
// $ANTLR end ANY_PRINT_CHAR

//   Comes from: 225:5: ( '_' ( NON_BLANK_CHAR_ )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TAG
 *
 * Looks to match the characters the constitute the token TAG
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTAG(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = TAG;


    // cif.g:225:5: ( '_' ( NON_BLANK_CHAR_ )+ )
    // cif.g:225:7: '_' ( NON_BLANK_CHAR_ )+
    {
        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleTAGEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        // cif.g:225:11: ( NON_BLANK_CHAR_ )+
        {
            int cnt6=0;

            for (;;)
            {
                int alt6=2;
                switch ( LA(1) )
                {
                case '!':
                case '"':
                case '#':
                case '$':
                case '%':
                case '&':
                case '\'':
                case '(':
                case ')':
                case '*':
                case '+':
                case ',':
                case '-':
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case '`':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                case '{':
                case '|':
                case '}':
                case '~':
                        {
                                alt6=1;
                        }
                    break;

                }

                switch (alt6)
                {
                    case 1:
                        // cif.g:225:12: NON_BLANK_CHAR_
                        {
                            /* 225:12: NON_BLANK_CHAR_ */
                            mNON_BLANK_CHAR_(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleTAGEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;

                    default:

                        if ( cnt6 >= 1 )
                        {
                            goto loop6;
                        }
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return ;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleTAGEx;
                }
                cnt6++;
            }
            loop6: ;    /* Jump to here if this rule does not match */
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTAGEx; /* Prevent compiler warnings */
    ruleTAGEx: ;

}
// $ANTLR end TAG

//   Comes from: 232:2: ( ';' ( ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* EOL ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )* ) ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEMI_COLON_TEXT_FIELD
 *
 * Looks to match the characters the constitute the token SEMI_COLON_TEXT_FIELD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSEMI_COLON_TEXT_FIELD(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = SEMI_COLON_TEXT_FIELD;


    // cif.g:232:2: ( ';' ( ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* EOL ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )* ) ';' )
    // cif.g:232:4: ';' ( ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* EOL ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )* ) ';'
    {
        MATCHC(';');
        if  (HASEXCEPTION())
        {
            goto ruleSEMI_COLON_TEXT_FIELDEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        // cif.g:233:3: ( ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* EOL ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )* )
        // cif.g:233:5: ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* EOL ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )*
        {

            // cif.g:233:5: ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )*

            for (;;)
            {
                int alt7=4;
                switch ( LA(1) )
                {
                case '\t':
                case ' ':
                case '!':
                case '#':
                case '$':
                case '%':
                case '&':
                case '(':
                case ')':
                case '*':
                case '+':
                case ',':
                case '-':
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case '`':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                case '{':
                case '|':
                case '}':
                case '~':
                        {
                                alt7=1;
                        }
                    break;
                case '\'':
                        {
                                alt7=2;
                        }
                    break;
                case '"':
                        {
                                alt7=3;
                        }
                    break;

                }

                switch (alt7)
                {
                case 1:
                    // cif.g:233:7: ANY_PRINT_CHAR
                    {
                        /* 233:7: ANY_PRINT_CHAR */
                        mANY_PRINT_CHAR(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 2:
                    // cif.g:233:24: SINGLE_QUOTE
                    {
                        /* 233:24: SINGLE_QUOTE */
                        mSINGLE_QUOTE(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 3:
                    // cif.g:233:39: DOUBLE_QUOTE
                    {
                        /* 233:39: DOUBLE_QUOTE */
                        mDOUBLE_QUOTE(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;

                default:
                    goto loop7; /* break out of the loop */
                    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */

            /* 233:5: ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* EOL ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )* */
            mEOL(ctx );
            if  (HASEXCEPTION())
            {
                goto ruleSEMI_COLON_TEXT_FIELDEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // cif.g:234:3: ( ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL )*

            for (;;)
            {
                int alt10=2;
                switch ( LA(1) )
                {
                case '\t':
                case '\n':
                case '\r':
                case ' ':
                case '!':
                case '"':
                case '#':
                case '$':
                case '%':
                case '&':
                case '\'':
                case '(':
                case ')':
                case '*':
                case '+':
                case ',':
                case '-':
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case '`':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                case '{':
                case '|':
                case '}':
                case '~':
                        {
                                alt10=1;
                        }
                    break;

                }

                switch (alt10)
                {
                case 1:
                    // cif.g:234:5: ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL
                    {

                        // cif.g:234:5: ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )?
                        {
                            int alt9=2;
                            switch ( LA(1) )
                            {
                                case '\t':
                                case ' ':
                                case '!':
                                case '"':
                                case '#':
                                case '$':
                                case '%':
                                case '&':
                                case '\'':
                                case '(':
                                case ')':
                                case '*':
                                case '+':
                                case ',':
                                case '-':
                                case '.':
                                case '/':
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                case ':':
                                case '<':
                                case '=':
                                case '>':
                                case '?':
                                case '@':
                                case 'A':
                                case 'B':
                                case 'C':
                                case 'D':
                                case 'E':
                                case 'F':
                                case 'G':
                                case 'H':
                                case 'I':
                                case 'J':
                                case 'K':
                                case 'L':
                                case 'M':
                                case 'N':
                                case 'O':
                                case 'P':
                                case 'Q':
                                case 'R':
                                case 'S':
                                case 'T':
                                case 'U':
                                case 'V':
                                case 'W':
                                case 'X':
                                case 'Y':
                                case 'Z':
                                case '[':
                                case '\\':
                                case ']':
                                case '^':
                                case '_':
                                case '`':
                                case 'a':
                                case 'b':
                                case 'c':
                                case 'd':
                                case 'e':
                                case 'f':
                                case 'g':
                                case 'h':
                                case 'i':
                                case 'j':
                                case 'k':
                                case 'l':
                                case 'm':
                                case 'n':
                                case 'o':
                                case 'p':
                                case 'q':
                                case 'r':
                                case 's':
                                case 't':
                                case 'u':
                                case 'v':
                                case 'w':
                                case 'x':
                                case 'y':
                                case 'z':
                                case '{':
                                case '|':
                                case '}':
                                case '~':
                                        {
                                                alt9=1;
                                        }
                                    break;
                            }

                            switch (alt9)
                            {
                                case 1:
                                    // cif.g:234:6: TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )*
                                    {
                                        /* 234:6: TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* */
                                        mTEXT_LEAD_CHAR(ctx );
                                        if  (HASEXCEPTION())
                                        {
                                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                                        }
                                        if (HASFAILED())
                                        {
                                            return ;
                                        }

                                        // cif.g:234:21: ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )*

                                        for (;;)
                                        {
                                            int alt8=4;
                                            switch ( LA(1) )
                                            {
                                            case '\t':
                                            case ' ':
                                            case '!':
                                            case '#':
                                            case '$':
                                            case '%':
                                            case '&':
                                            case '(':
                                            case ')':
                                            case '*':
                                            case '+':
                                            case ',':
                                            case '-':
                                            case '.':
                                            case '/':
                                            case '0':
                                            case '1':
                                            case '2':
                                            case '3':
                                            case '4':
                                            case '5':
                                            case '6':
                                            case '7':
                                            case '8':
                                            case '9':
                                            case ':':
                                            case ';':
                                            case '<':
                                            case '=':
                                            case '>':
                                            case '?':
                                            case '@':
                                            case 'A':
                                            case 'B':
                                            case 'C':
                                            case 'D':
                                            case 'E':
                                            case 'F':
                                            case 'G':
                                            case 'H':
                                            case 'I':
                                            case 'J':
                                            case 'K':
                                            case 'L':
                                            case 'M':
                                            case 'N':
                                            case 'O':
                                            case 'P':
                                            case 'Q':
                                            case 'R':
                                            case 'S':
                                            case 'T':
                                            case 'U':
                                            case 'V':
                                            case 'W':
                                            case 'X':
                                            case 'Y':
                                            case 'Z':
                                            case '[':
                                            case '\\':
                                            case ']':
                                            case '^':
                                            case '_':
                                            case '`':
                                            case 'a':
                                            case 'b':
                                            case 'c':
                                            case 'd':
                                            case 'e':
                                            case 'f':
                                            case 'g':
                                            case 'h':
                                            case 'i':
                                            case 'j':
                                            case 'k':
                                            case 'l':
                                            case 'm':
                                            case 'n':
                                            case 'o':
                                            case 'p':
                                            case 'q':
                                            case 'r':
                                            case 's':
                                            case 't':
                                            case 'u':
                                            case 'v':
                                            case 'w':
                                            case 'x':
                                            case 'y':
                                            case 'z':
                                            case '{':
                                            case '|':
                                            case '}':
                                            case '~':
                                                {
                                                        alt8=1;
                                                }
                                                break;
                                            case '\'':
                                                {
                                                        alt8=2;
                                                }
                                                break;
                                            case '"':
                                                {
                                                        alt8=3;
                                                }
                                                break;

                                            }

                                            switch (alt8)
                                            {
                                                case 1:
                                                    // cif.g:234:23: ANY_PRINT_CHAR
                                                    {
                                                        /* 234:23: ANY_PRINT_CHAR */
                                                        mANY_PRINT_CHAR(ctx );
                                                        if  (HASEXCEPTION())
                                                        {
                                                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                                                        }
                                                        if (HASFAILED())
                                                        {
                                                            return ;
                                                        }

                                                    }
                                                    break;
                                                case 2:
                                                    // cif.g:234:40: SINGLE_QUOTE
                                                    {
                                                        /* 234:40: SINGLE_QUOTE */
                                                        mSINGLE_QUOTE(ctx );
                                                        if  (HASEXCEPTION())
                                                        {
                                                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                                                        }
                                                        if (HASFAILED())
                                                        {
                                                            return ;
                                                        }

                                                    }
                                                    break;
                                                case 3:
                                                    // cif.g:234:55: DOUBLE_QUOTE
                                                    {
                                                        /* 234:55: DOUBLE_QUOTE */
                                                        mDOUBLE_QUOTE(ctx );
                                                        if  (HASEXCEPTION())
                                                        {
                                                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                                                        }
                                                        if (HASFAILED())
                                                        {
                                                            return ;
                                                        }

                                                    }
                                                    break;

                                                default:
                                                    goto loop8; /* break out of the loop */
                                                    break;
                                            }
                                        }
                                        loop8: ; /* Jump out to here if this rule does not match */


                                    }
                                    break;

                            }
                        }
                        /* 234:5: ( TEXT_LEAD_CHAR ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* )? EOL */
                        mEOL(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleSEMI_COLON_TEXT_FIELDEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;

                default:
                    goto loop10;        /* break out of the loop */
                    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


        }

        MATCHC(';');
        if  (HASEXCEPTION())
        {
            goto ruleSEMI_COLON_TEXT_FIELDEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSEMI_COLON_TEXT_FIELDEx; /* Prevent compiler warnings */
    ruleSEMI_COLON_TEXT_FIELDEx: ;

}
// $ANTLR end SEMI_COLON_TEXT_FIELD

//   Comes from: 243:7: ( ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'A' | 'a' ) '_' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DATA_
 *
 * Looks to match the characters the constitute the token DATA_
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDATA_(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // cif.g:243:7: ( ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'A' | 'a' ) '_' )
    // cif.g:243:9: ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'A' | 'a' ) '_'
    {
        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleDATA_Ex;
        }

        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleDATA_Ex;
        }

        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleDATA_Ex;
        }

        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleDATA_Ex;
        }

        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleDATA_Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleDATA_Ex; /* Prevent compiler warnings */
    ruleDATA_Ex: ;

}
// $ANTLR end DATA_

//   Comes from: 246:7: ( ( 'S' | 's' ) ( 'A' | 'a' ) ( 'V' | 'v' ) ( 'E' | 'e' ) '_' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAVE_
 *
 * Looks to match the characters the constitute the token SAVE_
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSAVE_(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // cif.g:246:7: ( ( 'S' | 's' ) ( 'A' | 'a' ) ( 'V' | 'v' ) ( 'E' | 'e' ) '_' )
    // cif.g:246:9: ( 'S' | 's' ) ( 'A' | 'a' ) ( 'V' | 'v' ) ( 'E' | 'e' ) '_'
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSAVE_Ex;
        }

        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSAVE_Ex;
        }

        if ( LA(1) == 'V' || LA(1) == 'v' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSAVE_Ex;
        }

        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSAVE_Ex;
        }

        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleSAVE_Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleSAVE_Ex; /* Prevent compiler warnings */
    ruleSAVE_Ex: ;

}
// $ANTLR end SAVE_

//   Comes from: 248:8: ( ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'O' | 'o' ) ( 'P' | 'p' ) '_' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LOOP_
 *
 * Looks to match the characters the constitute the token LOOP_
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLOOP_(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = LOOP_;


    // cif.g:248:8: ( ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'O' | 'o' ) ( 'P' | 'p' ) '_' )
    // cif.g:248:10: ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'O' | 'o' ) ( 'P' | 'p' ) '_'
    {
        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleLOOP_Ex;
        }

        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleLOOP_Ex;
        }

        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleLOOP_Ex;
        }

        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleLOOP_Ex;
        }

        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleLOOP_Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLOOP_Ex; /* Prevent compiler warnings */
    ruleLOOP_Ex: ;

}
// $ANTLR end LOOP_

//   Comes from: 250:9: ( ( 'G' | 'g' ) ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'B' | 'b' ) ( 'A' | 'a' ) ( 'L' | 'l' ) '_' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GLOBAL_
 *
 * Looks to match the characters the constitute the token GLOBAL_
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGLOBAL_(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = GLOBAL_;


    // cif.g:250:9: ( ( 'G' | 'g' ) ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'B' | 'b' ) ( 'A' | 'a' ) ( 'L' | 'l' ) '_' )
    // cif.g:250:11: ( 'G' | 'g' ) ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'B' | 'b' ) ( 'A' | 'a' ) ( 'L' | 'l' ) '_'
    {
        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleGLOBAL_Ex;
        }

        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleGLOBAL_Ex;
        }

        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleGLOBAL_Ex;
        }

        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleGLOBAL_Ex;
        }

        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleGLOBAL_Ex;
        }

        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleGLOBAL_Ex;
        }

        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleGLOBAL_Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleGLOBAL_Ex; /* Prevent compiler warnings */
    ruleGLOBAL_Ex: ;

}
// $ANTLR end GLOBAL_

//   Comes from: 252:7: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'O' | 'o' ) ( 'P' | 'p' ) '_' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STOP_
 *
 * Looks to match the characters the constitute the token STOP_
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTOP_(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = STOP_;


    // cif.g:252:7: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'O' | 'o' ) ( 'P' | 'p' ) '_' )
    // cif.g:252:9: ( 'S' | 's' ) ( 'T' | 't' ) ( 'O' | 'o' ) ( 'P' | 'p' ) '_'
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSTOP_Ex;
        }

        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSTOP_Ex;
        }

        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSTOP_Ex;
        }

        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSTOP_Ex;
        }

        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleSTOP_Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTOP_Ex; /* Prevent compiler warnings */
    ruleSTOP_Ex: ;

}
// $ANTLR end STOP_

//   Comes from: 261:2: ( DATA_ ( NON_BLANK_CHAR )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DATA_BLOCK_HEADING
 *
 * Looks to match the characters the constitute the token DATA_BLOCK_HEADING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDATA_BLOCK_HEADING(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = DATA_BLOCK_HEADING;


    // cif.g:261:2: ( DATA_ ( NON_BLANK_CHAR )+ )
    // cif.g:261:4: DATA_ ( NON_BLANK_CHAR )+
    {
        /* 261:4: DATA_ ( NON_BLANK_CHAR )+ */
        mDATA_(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDATA_BLOCK_HEADINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        // cif.g:261:10: ( NON_BLANK_CHAR )+
        {
            int cnt11=0;

            for (;;)
            {
                int alt11=2;
                switch ( LA(1) )
                {
                case '!':
                case '"':
                case '#':
                case '$':
                case '%':
                case '&':
                case '\'':
                case '(':
                case ')':
                case '*':
                case '+':
                case ',':
                case '-':
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case '`':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                case '{':
                case '|':
                case '}':
                case '~':
                        {
                                alt11=1;
                        }
                    break;

                }

                switch (alt11)
                {
                    case 1:
                        // cif.g:261:11: NON_BLANK_CHAR
                        {
                            /* 261:11: NON_BLANK_CHAR */
                            mNON_BLANK_CHAR(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleDATA_BLOCK_HEADINGEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;

                    default:

                        if ( cnt11 >= 1 )
                        {
                            goto loop11;
                        }
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return ;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleDATA_BLOCK_HEADINGEx;
                }
                cnt11++;
            }
            loop11: ;   /* Jump to here if this rule does not match */
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDATA_BLOCK_HEADINGEx; /* Prevent compiler warnings */
    ruleDATA_BLOCK_HEADINGEx: ;

}
// $ANTLR end DATA_BLOCK_HEADING

//   Comes from: 264:2: ( SAVE_ ( NON_BLANK_CHAR )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAVE_FRAME_HEADING
 *
 * Looks to match the characters the constitute the token SAVE_FRAME_HEADING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSAVE_FRAME_HEADING(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = SAVE_FRAME_HEADING;


    // cif.g:264:2: ( SAVE_ ( NON_BLANK_CHAR )+ )
    // cif.g:264:4: SAVE_ ( NON_BLANK_CHAR )+
    {
        /* 264:4: SAVE_ ( NON_BLANK_CHAR )+ */
        mSAVE_(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSAVE_FRAME_HEADINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        // cif.g:264:10: ( NON_BLANK_CHAR )+
        {
            int cnt12=0;

            for (;;)
            {
                int alt12=2;
                switch ( LA(1) )
                {
                case '!':
                case '"':
                case '#':
                case '$':
                case '%':
                case '&':
                case '\'':
                case '(':
                case ')':
                case '*':
                case '+':
                case ',':
                case '-':
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case '`':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                case '{':
                case '|':
                case '}':
                case '~':
                        {
                                alt12=1;
                        }
                    break;

                }

                switch (alt12)
                {
                    case 1:
                        // cif.g:264:11: NON_BLANK_CHAR
                        {
                            /* 264:11: NON_BLANK_CHAR */
                            mNON_BLANK_CHAR(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleSAVE_FRAME_HEADINGEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;

                    default:

                        if ( cnt12 >= 1 )
                        {
                            goto loop12;
                        }
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return ;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleSAVE_FRAME_HEADINGEx;
                }
                cnt12++;
            }
            loop12: ;   /* Jump to here if this rule does not match */
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSAVE_FRAME_HEADINGEx; /* Prevent compiler warnings */
    ruleSAVE_FRAME_HEADINGEx: ;

}
// $ANTLR end SAVE_FRAME_HEADING

//   Comes from: 266:6: ( SAVE_ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAVE
 *
 * Looks to match the characters the constitute the token SAVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSAVE(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = SAVE;


    // cif.g:266:6: ( SAVE_ )
    // cif.g:266:8: SAVE_
    {
        /* 266:8: SAVE_ */
        mSAVE_(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSAVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSAVEEx; /* Prevent compiler warnings */
    ruleSAVEEx: ;

}
// $ANTLR end SAVE

//   Comes from: 270:2: ( SINGLE_QUOTE ( ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE ) | ANY_PRINT_CHAR | DOUBLE_QUOTE )* SINGLE_QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SINGLE_QUOTED_STRING
 *
 * Looks to match the characters the constitute the token SINGLE_QUOTED_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSINGLE_QUOTED_STRING(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // cif.g:270:2: ( SINGLE_QUOTE ( ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE ) | ANY_PRINT_CHAR | DOUBLE_QUOTE )* SINGLE_QUOTE )
    // cif.g:270:4: SINGLE_QUOTE ( ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE ) | ANY_PRINT_CHAR | DOUBLE_QUOTE )* SINGLE_QUOTE
    {
        /* 270:4: SINGLE_QUOTE ( ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE ) | ANY_PRINT_CHAR | DOUBLE_QUOTE )* SINGLE_QUOTE */
        mSINGLE_QUOTE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSINGLE_QUOTED_STRINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // cif.g:271:3: ( ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE ) | ANY_PRINT_CHAR | DOUBLE_QUOTE )*

        for (;;)
        {
            int alt13=4;
            switch ( LA(1) )
            {
            case '\'':
                {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA13_1 = LA(2);
                            if ( (LA13_1 == '\'') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '!') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '%') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '&') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '(') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == ')') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '*') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '+') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == ',') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '-') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '.') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '/') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (((LA13_1 >= '0') && (LA13_1 <= '9'))) && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == ':') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '<') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '=') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '>') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '?') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '@') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (((LA13_1 >= 'A') && (LA13_1 <= 'Z'))) && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (((LA13_1 >= 'a') && (LA13_1 <= 'z'))) && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '\\') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '^') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '`') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '{') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '|') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '}') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '~') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '#') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '$') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '_') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '[') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == ']') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == ' ') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '\t') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == ';') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }
                            else if ( (LA13_1 == '"') && (synpred1_cif(ctx)))
                            {
                                alt13=1;
                            }

                        }
                }
                break;
            case '\t':
            case ' ':
            case '!':
            case '#':
            case '$':
            case '%':
            case '&':
            case '(':
            case ')':
            case '*':
            case '+':
            case ',':
            case '-':
            case '.':
            case '/':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case ':':
            case ';':
            case '<':
            case '=':
            case '>':
            case '?':
            case '@':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '[':
            case '\\':
            case ']':
            case '^':
            case '_':
            case '`':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            case '{':
            case '|':
            case '}':
            case '~':
                {
                        alt13=2;
                }
                break;
            case '"':
                {
                        alt13=3;
                }
                break;

            }

            switch (alt13)
            {
                case 1:
                    // cif.g:271:5: ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE )
                    {
                        // cif.g:271:5: ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE )
                        // cif.g:271:7: ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE
                        {
                            /* 271:7: ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE */
                            mSINGLE_QUOTE(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleSINGLE_QUOTED_STRINGEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }


                    }
                    break;
                case 2:
                    // cif.g:271:56: ANY_PRINT_CHAR
                    {
                        /* 271:56: ANY_PRINT_CHAR */
                        mANY_PRINT_CHAR(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleSINGLE_QUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 3:
                    // cif.g:271:73: DOUBLE_QUOTE
                    {
                        /* 271:73: DOUBLE_QUOTE */
                        mDOUBLE_QUOTE(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleSINGLE_QUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;

                default:
                    goto loop13;        /* break out of the loop */
                    break;
            }
        }
        loop13: ; /* Jump out to here if this rule does not match */

        /* 270:4: SINGLE_QUOTE ( ( ( SINGLE_QUOTE NON_BLANK_CHAR_ )=> SINGLE_QUOTE ) | ANY_PRINT_CHAR | DOUBLE_QUOTE )* SINGLE_QUOTE */
        mSINGLE_QUOTE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSINGLE_QUOTED_STRINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleSINGLE_QUOTED_STRINGEx; /* Prevent compiler warnings */
    ruleSINGLE_QUOTED_STRINGEx: ;

}
// $ANTLR end SINGLE_QUOTED_STRING

//   Comes from: 276:2: ( DOUBLE_QUOTE ( ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE ) | ANY_PRINT_CHAR | SINGLE_QUOTE )* DOUBLE_QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_QUOTED_STRING
 *
 * Looks to match the characters the constitute the token DOUBLE_QUOTED_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOUBLE_QUOTED_STRING(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // cif.g:276:2: ( DOUBLE_QUOTE ( ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE ) | ANY_PRINT_CHAR | SINGLE_QUOTE )* DOUBLE_QUOTE )
    // cif.g:276:4: DOUBLE_QUOTE ( ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE ) | ANY_PRINT_CHAR | SINGLE_QUOTE )* DOUBLE_QUOTE
    {
        /* 276:4: DOUBLE_QUOTE ( ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE ) | ANY_PRINT_CHAR | SINGLE_QUOTE )* DOUBLE_QUOTE */
        mDOUBLE_QUOTE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_QUOTED_STRINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // cif.g:277:3: ( ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE ) | ANY_PRINT_CHAR | SINGLE_QUOTE )*

        for (;;)
        {
            int alt14=4;
            switch ( LA(1) )
            {
            case '"':
                {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA14_1 = LA(2);
                            if ( (LA14_1 == '"') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '!') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '%') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '&') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '(') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == ')') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '*') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '+') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == ',') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '-') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '.') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '/') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (((LA14_1 >= '0') && (LA14_1 <= '9'))) && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == ':') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '<') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '=') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '>') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '?') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '@') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (((LA14_1 >= 'A') && (LA14_1 <= 'Z'))) && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (((LA14_1 >= 'a') && (LA14_1 <= 'z'))) && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '\\') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '^') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '`') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '{') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '|') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '}') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '~') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '#') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '$') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '_') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '[') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == ']') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == ' ') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '\t') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == ';') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }
                            else if ( (LA14_1 == '\'') && (synpred2_cif(ctx)))
                            {
                                alt14=1;
                            }

                        }
                }
                break;
            case '\t':
            case ' ':
            case '!':
            case '#':
            case '$':
            case '%':
            case '&':
            case '(':
            case ')':
            case '*':
            case '+':
            case ',':
            case '-':
            case '.':
            case '/':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case ':':
            case ';':
            case '<':
            case '=':
            case '>':
            case '?':
            case '@':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '[':
            case '\\':
            case ']':
            case '^':
            case '_':
            case '`':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            case '{':
            case '|':
            case '}':
            case '~':
                {
                        alt14=2;
                }
                break;
            case '\'':
                {
                        alt14=3;
                }
                break;

            }

            switch (alt14)
            {
                case 1:
                    // cif.g:277:5: ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE )
                    {
                        // cif.g:277:5: ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE )
                        // cif.g:277:7: ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE
                        {
                            /* 277:7: ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE */
                            mDOUBLE_QUOTE(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleDOUBLE_QUOTED_STRINGEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }


                    }
                    break;
                case 2:
                    // cif.g:277:56: ANY_PRINT_CHAR
                    {
                        /* 277:56: ANY_PRINT_CHAR */
                        mANY_PRINT_CHAR(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleDOUBLE_QUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 3:
                    // cif.g:277:73: SINGLE_QUOTE
                    {
                        /* 277:73: SINGLE_QUOTE */
                        mSINGLE_QUOTE(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleDOUBLE_QUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;

                default:
                    goto loop14;        /* break out of the loop */
                    break;
            }
        }
        loop14: ; /* Jump out to here if this rule does not match */

        /* 276:4: DOUBLE_QUOTE ( ( ( DOUBLE_QUOTE NON_BLANK_CHAR_ )=> DOUBLE_QUOTE ) | ANY_PRINT_CHAR | SINGLE_QUOTE )* DOUBLE_QUOTE */
        mDOUBLE_QUOTE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_QUOTED_STRINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_QUOTED_STRINGEx; /* Prevent compiler warnings */
    ruleDOUBLE_QUOTED_STRINGEx: ;

}
// $ANTLR end DOUBLE_QUOTED_STRING

//   Comes from: 285:16: ( '0' .. '9' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIGIT
 *
 * Looks to match the characters the constitute the token DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDIGIT(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // cif.g:285:16: ( '0' .. '9' )
    // cif.g:285:18: '0' .. '9'
    {
        MATCHRANGE('0', '9');
        if  (HASEXCEPTION())
        {
            goto ruleDIGITEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleDIGITEx; /* Prevent compiler warnings */
    ruleDIGITEx: ;

}
// $ANTLR end DIGIT

//   Comes from: 287:18: ( ( ( 'e' | 'E' ) | ( 'e' | 'E' ) ( '+' | '-' ) ) ( DIGIT )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXPONENT
 *
 * Looks to match the characters the constitute the token EXPONENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXPONENT(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // cif.g:287:18: ( ( ( 'e' | 'E' ) | ( 'e' | 'E' ) ( '+' | '-' ) ) ( DIGIT )+ )
    // cif.g:287:21: ( ( 'e' | 'E' ) | ( 'e' | 'E' ) ( '+' | '-' ) ) ( DIGIT )+
    {

        // cif.g:287:21: ( ( 'e' | 'E' ) | ( 'e' | 'E' ) ( '+' | '-' ) )
        {
            int alt15=2;
            switch ( LA(1) )
            {
            case 'E':
            case 'e':
                {
                        switch ( LA(2) )
                        {
                        case '+':
                        case '-':
                                {
                                        alt15=2;
                                }
                            break;
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                                {
                                        alt15=1;
                                }
                            break;

                        default:
                            if (BACKTRACKING>0)
                            {
                                FAILEDFLAG = ANTLR3_TRUE;
                                return ;
                            }
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 15;
                            EXCEPTION->state        = 1;


                            goto ruleEXPONENTEx;
                        }

                }
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;


                goto ruleEXPONENTEx;
            }

            switch (alt15)
            {
                case 1:
                    // cif.g:287:23: ( 'e' | 'E' )
                    {
                        if ( LA(1) == 'E' || LA(1) == 'e' )
                        {
                            CONSUME();
                        FAILEDFLAG=ANTLR3_FALSE;

                        }
                        else
                        {
                            if (BACKTRACKING>0)
                            {
                                FAILEDFLAG = ANTLR3_TRUE;
                                return ;
                            }
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                            LRECOVER();    goto ruleEXPONENTEx;
                        }


                    }
                    break;
                case 2:
                    // cif.g:287:38: ( 'e' | 'E' ) ( '+' | '-' )
                    {
                        if ( LA(1) == 'E' || LA(1) == 'e' )
                        {
                            CONSUME();
                        FAILEDFLAG=ANTLR3_FALSE;

                        }
                        else
                        {
                            if (BACKTRACKING>0)
                            {
                                FAILEDFLAG = ANTLR3_TRUE;
                                return ;
                            }
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                            LRECOVER();    goto ruleEXPONENTEx;
                        }

                        if ( LA(1) == '+' || LA(1) == '-' )
                        {
                            CONSUME();
                        FAILEDFLAG=ANTLR3_FALSE;

                        }
                        else
                        {
                            if (BACKTRACKING>0)
                            {
                                FAILEDFLAG = ANTLR3_TRUE;
                                return ;
                            }
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                            LRECOVER();    goto ruleEXPONENTEx;
                        }


                    }
                    break;

            }
        }
        // cif.g:287:66: ( DIGIT )+
        {
            int cnt16=0;

            for (;;)
            {
                int alt16=2;
                switch ( LA(1) )
                {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                        {
                                alt16=1;
                        }
                    break;

                }

                switch (alt16)
                {
                    case 1:
                        // cif.g:287:67: DIGIT
                        {
                            /* 287:67: DIGIT */
                            mDIGIT(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleEXPONENTEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;

                    default:

                        if ( cnt16 >= 1 )
                        {
                            goto loop16;
                        }
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return ;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleEXPONENTEx;
                }
                cnt16++;
            }
            loop16: ;   /* Jump to here if this rule does not match */
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleEXPONENTEx; /* Prevent compiler warnings */
    ruleEXPONENTEx: ;

}
// $ANTLR end EXPONENT

//   Comes from: 289:18: ( ( '+' | '-' )? ( DIGIT )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INTEGER
 *
 * Looks to match the characters the constitute the token INTEGER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINTEGER(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // cif.g:289:18: ( ( '+' | '-' )? ( DIGIT )+ )
    // cif.g:289:21: ( '+' | '-' )? ( DIGIT )+
    {

        // cif.g:289:21: ( '+' | '-' )?
        {
            int alt17=2;
            switch ( LA(1) )
            {
                case '+':
                case '-':
                        {
                                alt17=1;
                        }
                    break;
            }

            switch (alt17)
            {
                case 1:
                    // cif.g:
                    {
                        if ( LA(1) == '+' || LA(1) == '-' )
                        {
                            CONSUME();
                        FAILEDFLAG=ANTLR3_FALSE;

                        }
                        else
                        {
                            if (BACKTRACKING>0)
                            {
                                FAILEDFLAG = ANTLR3_TRUE;
                                return ;
                            }
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                            LRECOVER();    goto ruleINTEGEREx;
                        }


                    }
                    break;

            }
        }
        // cif.g:289:36: ( DIGIT )+
        {
            int cnt18=0;

            for (;;)
            {
                int alt18=2;
                switch ( LA(1) )
                {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                        {
                                alt18=1;
                        }
                    break;

                }

                switch (alt18)
                {
                    case 1:
                        // cif.g:289:37: DIGIT
                        {
                            /* 289:37: DIGIT */
                            mDIGIT(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleINTEGEREx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;

                    default:

                        if ( cnt18 >= 1 )
                        {
                            goto loop18;
                        }
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return ;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleINTEGEREx;
                }
                cnt18++;
            }
            loop18: ;   /* Jump to here if this rule does not match */
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleINTEGEREx; /* Prevent compiler warnings */
    ruleINTEGEREx: ;

}
// $ANTLR end INTEGER

//   Comes from: 292:2: ( INTEGER EXPONENT | ( ( '+' | '-' )? ( ( DIGIT )* '.' ( DIGIT )+ ) | ( DIGIT )+ '.' ) ( EXPONENT )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOAT
 *
 * Looks to match the characters the constitute the token FLOAT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOAT(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = FLOAT;


    {
        //  cif.g:292:2: ( INTEGER EXPONENT | ( ( '+' | '-' )? ( ( DIGIT )* '.' ( DIGIT )+ ) | ( DIGIT )+ '.' ) ( EXPONENT )? )

        ANTLR3_UINT32 alt25;

        alt25=2;

        alt25 = cdfa25.predict(ctx, RECOGNIZER, ISTREAM, &cdfa25);
        if  (HASEXCEPTION())
        {
            goto ruleFLOATEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        switch (alt25)
        {
        case 1:
            // cif.g:292:5: INTEGER EXPONENT
            {
                /* 292:5: INTEGER EXPONENT */
                mINTEGER(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleFLOATEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
                /* 292:5: INTEGER EXPONENT */
                mEXPONENT(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleFLOATEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 2:
            // cif.g:292:24: ( ( '+' | '-' )? ( ( DIGIT )* '.' ( DIGIT )+ ) | ( DIGIT )+ '.' ) ( EXPONENT )?
            {

                // cif.g:292:24: ( ( '+' | '-' )? ( ( DIGIT )* '.' ( DIGIT )+ ) | ( DIGIT )+ '.' )
                {
                    int alt23=2;
                    alt23 = cdfa23.predict(ctx, RECOGNIZER, ISTREAM, &cdfa23);
                    if  (HASEXCEPTION())
                    {
                        goto ruleFLOATEx;
                    }
                    if (HASFAILED())
                    {
                        return ;
                    }
                    switch (alt23)
                    {
                        case 1:
                            // cif.g:292:26: ( '+' | '-' )? ( ( DIGIT )* '.' ( DIGIT )+ )
                            {

                                // cif.g:292:26: ( '+' | '-' )?
                                {
                                    int alt19=2;
                                    switch ( LA(1) )
                                    {
                                        case '+':
                                        case '-':
                                                {
                                                        alt19=1;
                                                }
                                            break;
                                    }

                                    switch (alt19)
                                    {
                                        case 1:
                                            // cif.g:
                                            {
                                                if ( LA(1) == '+' || LA(1) == '-' )
                                                {
                                                    CONSUME();
                                                FAILEDFLAG=ANTLR3_FALSE;

                                                }
                                                else
                                                {
                                                    if (BACKTRACKING>0)
                                                    {
                                                        FAILEDFLAG = ANTLR3_TRUE;
                                                        return ;
                                                    }
                                                    CONSTRUCTEX();
                                                    EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                                                    EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                                                    LRECOVER();    goto ruleFLOATEx;
                                                }


                                            }
                                            break;

                                    }
                                }
                                // cif.g:292:41: ( ( DIGIT )* '.' ( DIGIT )+ )
                                // cif.g:292:43: ( DIGIT )* '.' ( DIGIT )+
                                {

                                    // cif.g:292:43: ( DIGIT )*

                                    for (;;)
                                    {
                                        int alt20=2;
                                        switch ( LA(1) )
                                        {
                                        case '0':
                                        case '1':
                                        case '2':
                                        case '3':
                                        case '4':
                                        case '5':
                                        case '6':
                                        case '7':
                                        case '8':
                                        case '9':
                                                {
                                                        alt20=1;
                                                }
                                            break;

                                        }

                                        switch (alt20)
                                        {
                                        case 1:
                                            // cif.g:292:44: DIGIT
                                            {
                                                /* 292:44: DIGIT */
                                                mDIGIT(ctx );
                                                if  (HASEXCEPTION())
                                                {
                                                    goto ruleFLOATEx;
                                                }
                                                if (HASFAILED())
                                                {
                                                    return ;
                                                }

                                            }
                                            break;

                                        default:
                                            goto loop20;        /* break out of the loop */
                                            break;
                                        }
                                    }
                                    loop20: ; /* Jump out to here if this rule does not match */

                                    MATCHC('.');
                                    if  (HASEXCEPTION())
                                    {
                                        goto ruleFLOATEx;
                                    }
                                    if (HASFAILED())
                                    {
                                        return ;
                                    }
                                    // cif.g:292:56: ( DIGIT )+
                                    {
                                        int cnt21=0;

                                        for (;;)
                                        {
                                            int alt21=2;
                                        switch ( LA(1) )
                                        {
                                        case '0':
                                        case '1':
                                        case '2':
                                        case '3':
                                        case '4':
                                        case '5':
                                        case '6':
                                        case '7':
                                        case '8':
                                        case '9':
                                                {
                                                        alt21=1;
                                                }
                                            break;

                                        }

                                        switch (alt21)
                                        {
                                            case 1:
                                                // cif.g:292:57: DIGIT
                                                {
                                                    /* 292:57: DIGIT */
                                                    mDIGIT(ctx );
                                                    if  (HASEXCEPTION())
                                                    {
                                                        goto ruleFLOATEx;
                                                    }
                                                    if (HASFAILED())
                                                    {
                                                        return ;
                                                    }

                                                }
                                                break;

                                            default:

                                                if ( cnt21 >= 1 )
                                                {
                                                    goto loop21;
                                                }
                                                if (BACKTRACKING>0)
                                                {
                                                    FAILEDFLAG = ANTLR3_TRUE;
                                                    return ;
                                                }
                                                /* mismatchedSetEx()
                                                 */
                                                CONSTRUCTEX();
                                                EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                                                EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                                                goto ruleFLOATEx;
                                        }
                                        cnt21++;
                                        }
                                        loop21: ;       /* Jump to here if this rule does not match */
                                    }

                                }


                            }
                            break;
                        case 2:
                            // cif.g:292:68: ( DIGIT )+ '.'
                            {
                                // cif.g:292:68: ( DIGIT )+
                                {
                                    int cnt22=0;

                                    for (;;)
                                    {
                                        int alt22=2;
                                        switch ( LA(1) )
                                        {
                                        case '0':
                                        case '1':
                                        case '2':
                                        case '3':
                                        case '4':
                                        case '5':
                                        case '6':
                                        case '7':
                                        case '8':
                                        case '9':
                                                {
                                                        alt22=1;
                                                }
                                            break;

                                        }

                                        switch (alt22)
                                        {
                                            case 1:
                                                // cif.g:292:69: DIGIT
                                                {
                                                    /* 292:69: DIGIT */
                                                    mDIGIT(ctx );
                                                    if  (HASEXCEPTION())
                                                    {
                                                        goto ruleFLOATEx;
                                                    }
                                                    if (HASFAILED())
                                                    {
                                                        return ;
                                                    }

                                                }
                                                break;

                                            default:

                                                if ( cnt22 >= 1 )
                                                {
                                                    goto loop22;
                                                }
                                                if (BACKTRACKING>0)
                                                {
                                                    FAILEDFLAG = ANTLR3_TRUE;
                                                    return ;
                                                }
                                                /* mismatchedSetEx()
                                                 */
                                                CONSTRUCTEX();
                                                EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                                                EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                                                goto ruleFLOATEx;
                                        }
                                        cnt22++;
                                    }
                                    loop22: ;   /* Jump to here if this rule does not match */
                                }
                                MATCHC('.');
                                if  (HASEXCEPTION())
                                {
                                    goto ruleFLOATEx;
                                }
                                if (HASFAILED())
                                {
                                    return ;
                                }

                            }
                            break;

                    }
                }

                // cif.g:292:83: ( EXPONENT )?
                {
                    int alt24=2;
                    switch ( LA(1) )
                    {
                        case 'E':
                        case 'e':
                                {
                                        alt24=1;
                                }
                            break;
                    }

                    switch (alt24)
                    {
                        case 1:
                            // cif.g:292:84: EXPONENT
                            {
                                /* 292:84: EXPONENT */
                                mEXPONENT(ctx );
                                if  (HASEXCEPTION())
                                {
                                    goto ruleFLOATEx;
                                }
                                if (HASFAILED())
                                {
                                    return ;
                                }

                            }
                            break;

                    }
                }

            }
            break;

        }
    }
        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLOATEx; /* Prevent compiler warnings */
    ruleFLOATEx: ;

}
// $ANTLR end FLOAT

//   Comes from: 295:2: ( ( DIGIT )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNSIGNED_INTEGER
 *
 * Looks to match the characters the constitute the token UNSIGNED_INTEGER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNSIGNED_INTEGER(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = UNSIGNED_INTEGER;


    // cif.g:295:2: ( ( DIGIT )+ )
    // cif.g:295:4: ( DIGIT )+
    {
        // cif.g:295:4: ( DIGIT )+
        {
            int cnt26=0;

            for (;;)
            {
                int alt26=2;
                switch ( LA(1) )
                {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                        {
                                alt26=1;
                        }
                    break;

                }

                switch (alt26)
                {
                    case 1:
                        // cif.g:295:5: DIGIT
                        {
                            /* 295:5: DIGIT */
                            mDIGIT(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleUNSIGNED_INTEGEREx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;

                    default:

                        if ( cnt26 >= 1 )
                        {
                            goto loop26;
                        }
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return ;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleUNSIGNED_INTEGEREx;
                }
                cnt26++;
            }
            loop26: ;   /* Jump to here if this rule does not match */
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleUNSIGNED_INTEGEREx; /* Prevent compiler warnings */
    ruleUNSIGNED_INTEGEREx: ;

}
// $ANTLR end UNSIGNED_INTEGER

//   Comes from: 300:2: ( ( ORDINARY_CHAR | ';' ) ( NON_BLANK_CHAR_ )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNQUOTED_STRING
 *
 * Looks to match the characters the constitute the token UNQUOTED_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNQUOTED_STRING(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;


    // cif.g:300:2: ( ( ORDINARY_CHAR | ';' ) ( NON_BLANK_CHAR_ )* )
    // cif.g:300:4: ( ORDINARY_CHAR | ';' ) ( NON_BLANK_CHAR_ )*
    {

        // cif.g:300:4: ( ORDINARY_CHAR | ';' )
        {
            int alt27=2;
            switch ( LA(1) )
            {
            case '!':
            case '%':
            case '&':
            case '(':
            case ')':
            case '*':
            case '+':
            case ',':
            case '-':
            case '.':
            case '/':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case ':':
            case '<':
            case '=':
            case '>':
            case '?':
            case '@':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '\\':
            case '^':
            case '`':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            case '{':
            case '|':
            case '}':
            case '~':
                {
                        alt27=1;
                }
                break;
            case ';':
                {
                        alt27=2;
                }
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 27;
                EXCEPTION->state        = 0;


                goto ruleUNQUOTED_STRINGEx;
            }

            switch (alt27)
            {
                case 1:
                    // cif.g:300:6: ORDINARY_CHAR
                    {
                        /* 300:6: ORDINARY_CHAR */
                        mORDINARY_CHAR(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleUNQUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;
                case 2:
                    // cif.g:300:22: ';'
                    {
                        MATCHC(';');
                        if  (HASEXCEPTION())
                        {
                            goto ruleUNQUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;

            }
        }

        // cif.g:300:28: ( NON_BLANK_CHAR_ )*

        for (;;)
        {
            int alt28=2;
            switch ( LA(1) )
            {
            case '!':
            case '"':
            case '#':
            case '$':
            case '%':
            case '&':
            case '\'':
            case '(':
            case ')':
            case '*':
            case '+':
            case ',':
            case '-':
            case '.':
            case '/':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case ':':
            case ';':
            case '<':
            case '=':
            case '>':
            case '?':
            case '@':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '[':
            case '\\':
            case ']':
            case '^':
            case '_':
            case '`':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            case '{':
            case '|':
            case '}':
            case '~':
                {
                        alt28=1;
                }
                break;

            }

            switch (alt28)
            {
                case 1:
                    // cif.g:300:29: NON_BLANK_CHAR_
                    {
                        /* 300:29: NON_BLANK_CHAR_ */
                        mNON_BLANK_CHAR_(ctx );
                        if  (HASEXCEPTION())
                        {
                            goto ruleUNQUOTED_STRINGEx;
                        }
                        if (HASFAILED())
                        {
                            return ;
                        }

                    }
                    break;

                default:
                    goto loop28;        /* break out of the loop */
                    break;
            }
        }
        loop28: ; /* Jump out to here if this rule does not match */


    }



    // This is where rules clean up and exit
    //
    goto ruleUNQUOTED_STRINGEx; /* Prevent compiler warnings */
    ruleUNQUOTED_STRINGEx: ;

}
// $ANTLR end UNQUOTED_STRING

//   Comes from: 303:2: ( SINGLE_QUOTED_STRING | DOUBLE_QUOTED_STRING | UNQUOTED_STRING )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHAR_STRING
 *
 * Looks to match the characters the constitute the token CHAR_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCHAR_STRING(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = CHAR_STRING;


    {
        //  cif.g:303:2: ( SINGLE_QUOTED_STRING | DOUBLE_QUOTED_STRING | UNQUOTED_STRING )

        ANTLR3_UINT32 alt29;

        alt29=3;

        switch ( LA(1) )
        {
        case '\'':
                {
                        alt29=1;
                }
            break;
        case '"':
                {
                        alt29=2;
                }
            break;
        case '!':
        case '%':
        case '&':
        case '(':
        case ')':
        case '*':
        case '+':
        case ',':
        case '-':
        case '.':
        case '/':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case ':':
        case ';':
        case '<':
        case '=':
        case '>':
        case '?':
        case '@':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '\\':
        case '^':
        case '`':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
        case '{':
        case '|':
        case '}':
        case '~':
                {
                        alt29=3;
                }
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 29;
            EXCEPTION->state        = 0;


            goto ruleCHAR_STRINGEx;
        }

        switch (alt29)
        {
        case 1:
            // cif.g:303:4: SINGLE_QUOTED_STRING
            {
                /* 303:4: SINGLE_QUOTED_STRING */
                mSINGLE_QUOTED_STRING(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleCHAR_STRINGEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 2:
            // cif.g:303:27: DOUBLE_QUOTED_STRING
            {
                /* 303:27: DOUBLE_QUOTED_STRING */
                mDOUBLE_QUOTED_STRING(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleCHAR_STRINGEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 3:
            // cif.g:303:50: UNQUOTED_STRING
            {
                /* 303:50: UNQUOTED_STRING */
                mUNQUOTED_STRING(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleCHAR_STRINGEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;

        }
    }
        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCHAR_STRINGEx; /* Prevent compiler warnings */
    ruleCHAR_STRINGEx: ;

}
// $ANTLR end CHAR_STRING

//   Comes from: 310:2: ( ( ( '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?) )+ ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENTS
 *
 * Looks to match the characters the constitute the token COMMENTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENTS(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = COMMENTS;


    // cif.g:310:2: ( ( ( '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?) )+ ) )
    // cif.g:310:4: ( ( '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?) )+ )
    {
        // cif.g:310:4: ( ( '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?) )+ )
        // cif.g:310:6: ( '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?) )+
        {
            // cif.g:310:6: ( '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?) )+
            {
                int cnt32=0;

                for (;;)
                {
                    int alt32=2;
                switch ( LA(1) )
                {
                case '#':
                        {
                                alt32=1;
                        }
                    break;

                }

                switch (alt32)
                {
                    case 1:
                        // cif.g:310:8: '#' ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )* ( EOL | {...}?)
                        {
                            MATCHC('#');
                            if  (HASEXCEPTION())
                            {
                                goto ruleCOMMENTSEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                            // cif.g:310:12: ( ANY_PRINT_CHAR | SINGLE_QUOTE | DOUBLE_QUOTE )*

                            for (;;)
                            {
                                int alt30=4;
                                switch ( LA(1) )
                                {
                                case '#':
                                        {
                                                {
                                                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                                    */
                                                    int LA30_2 = LA(2);
                                                    if ( (!( (( LA(1) == EOF )) )) )
                                                    {
                                                        alt30=1;
                                                    }

                                                }
                                        }
                                    break;
                                case '\t':
                                case ' ':
                                case '!':
                                case '$':
                                case '%':
                                case '&':
                                case '(':
                                case ')':
                                case '*':
                                case '+':
                                case ',':
                                case '-':
                                case '.':
                                case '/':
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                case ':':
                                case ';':
                                case '<':
                                case '=':
                                case '>':
                                case '?':
                                case '@':
                                case 'A':
                                case 'B':
                                case 'C':
                                case 'D':
                                case 'E':
                                case 'F':
                                case 'G':
                                case 'H':
                                case 'I':
                                case 'J':
                                case 'K':
                                case 'L':
                                case 'M':
                                case 'N':
                                case 'O':
                                case 'P':
                                case 'Q':
                                case 'R':
                                case 'S':
                                case 'T':
                                case 'U':
                                case 'V':
                                case 'W':
                                case 'X':
                                case 'Y':
                                case 'Z':
                                case '[':
                                case '\\':
                                case ']':
                                case '^':
                                case '_':
                                case '`':
                                case 'a':
                                case 'b':
                                case 'c':
                                case 'd':
                                case 'e':
                                case 'f':
                                case 'g':
                                case 'h':
                                case 'i':
                                case 'j':
                                case 'k':
                                case 'l':
                                case 'm':
                                case 'n':
                                case 'o':
                                case 'p':
                                case 'q':
                                case 'r':
                                case 's':
                                case 't':
                                case 'u':
                                case 'v':
                                case 'w':
                                case 'x':
                                case 'y':
                                case 'z':
                                case '{':
                                case '|':
                                case '}':
                                case '~':
                                        {
                                                alt30=1;
                                        }
                                    break;
                                case '\'':
                                        {
                                                alt30=2;
                                        }
                                    break;
                                case '"':
                                        {
                                                alt30=3;
                                        }
                                    break;

                                }

                                switch (alt30)
                                {
                                case 1:
                                    // cif.g:310:13: ANY_PRINT_CHAR
                                    {
                                        /* 310:13: ANY_PRINT_CHAR */
                                        mANY_PRINT_CHAR(ctx );
                                        if  (HASEXCEPTION())
                                        {
                                            goto ruleCOMMENTSEx;
                                        }
                                        if (HASFAILED())
                                        {
                                            return ;
                                        }

                                    }
                                    break;
                                case 2:
                                    // cif.g:310:30: SINGLE_QUOTE
                                    {
                                        /* 310:30: SINGLE_QUOTE */
                                        mSINGLE_QUOTE(ctx );
                                        if  (HASEXCEPTION())
                                        {
                                            goto ruleCOMMENTSEx;
                                        }
                                        if (HASFAILED())
                                        {
                                            return ;
                                        }

                                    }
                                    break;
                                case 3:
                                    // cif.g:310:45: DOUBLE_QUOTE
                                    {
                                        /* 310:45: DOUBLE_QUOTE */
                                        mDOUBLE_QUOTE(ctx );
                                        if  (HASEXCEPTION())
                                        {
                                            goto ruleCOMMENTSEx;
                                        }
                                        if (HASFAILED())
                                        {
                                            return ;
                                        }

                                    }
                                    break;

                                default:
                                    goto loop30;        /* break out of the loop */
                                    break;
                                }
                            }
                            loop30: ; /* Jump out to here if this rule does not match */


                            // cif.g:311:7: ( EOL | {...}?)
                            {
                                int alt31=2;
                                switch ( LA(1) )
                                {
                                case '\n':
                                case '\r':
                                        {
                                                alt31=1;
                                        }
                                    break;

                                default:
                                    alt31=2;}

                                switch (alt31)
                                {
                                case 1:
                                    // cif.g:311:9: EOL
                                    {
                                        /* 311:9: EOL */
                                        mEOL(ctx );
                                        if  (HASEXCEPTION())
                                        {
                                            goto ruleCOMMENTSEx;
                                        }
                                        if (HASFAILED())
                                        {
                                            return ;
                                        }

                                    }
                                    break;
                                case 2:
                                    // cif.g:311:15: {...}?
                                    {
                                        if ( !(( LA(1) == EOF )) )
                                        {
                                            if (BACKTRACKING>0)
                                            {
                                                FAILEDFLAG = ANTLR3_TRUE;
                                                return ;
                                            }
                                                CONSTRUCTEX();
                                                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                                                EXCEPTION->message      = (void *)" LA(1) == EOF ";
                                                EXCEPTION->ruleName      = (void *)"COMMENTS";


                                        }

                                    }
                                    break;

                                }
                            }

                        }
                        break;

                    default:

                        if ( cnt32 >= 1 )
                        {
                            goto loop32;
                        }
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return ;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleCOMMENTSEx;
                }
                cnt32++;
                }
                loop32: ;       /* Jump to here if this rule does not match */
            }

        }

        if ( BACKTRACKING==0 )
        {
             LEXSTATE->channel = HIDDEN;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCOMMENTSEx; /* Prevent compiler warnings */
    ruleCOMMENTSEx: ;

}
// $ANTLR end COMMENTS

//   Comes from: 324:2: ( NON_BLANK_CHAR_ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NON_BLANK_CHAR
 *
 * Looks to match the characters the constitute the token NON_BLANK_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNON_BLANK_CHAR(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = NON_BLANK_CHAR;


    // cif.g:324:2: ( NON_BLANK_CHAR_ )
    // cif.g:324:4: NON_BLANK_CHAR_
    {
        /* 324:4: NON_BLANK_CHAR_ */
        mNON_BLANK_CHAR_(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleNON_BLANK_CHAREx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNON_BLANK_CHAREx; /* Prevent compiler warnings */
    ruleNON_BLANK_CHAREx: ;

}
// $ANTLR end NON_BLANK_CHAR

//   Comes from: 327:2: ( ( '\\t' | ' ' | EOL | '\\u000C' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHITESPACE
 *
 * Looks to match the characters the constitute the token WHITESPACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWHITESPACE(pcifLexer ctx)
{
        ANTLR3_UINT32   _type;

    _type           = WHITESPACE;


    // cif.g:327:2: ( ( '\\t' | ' ' | EOL | '\\u000C' )+ )
    // cif.g:327:5: ( '\\t' | ' ' | EOL | '\\u000C' )+
    {
        // cif.g:327:5: ( '\\t' | ' ' | EOL | '\\u000C' )+
        {
            int cnt33=0;

            for (;;)
            {
                int alt33=5;
                switch ( LA(1) )
                {
                case '\t':
                        {
                                alt33=1;
                        }
                    break;
                case ' ':
                        {
                                alt33=2;
                        }
                    break;
                case '\n':
                case '\r':
                        {
                                alt33=3;
                        }
                    break;
                case '\f':
                        {
                                alt33=4;
                        }
                    break;

                }

                switch (alt33)
                {
                    case 1:
                        // cif.g:327:7: '\\t'
                        {
                            MATCHC('\t');
                            if  (HASEXCEPTION())
                            {
                                goto ruleWHITESPACEEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;
                    case 2:
                        // cif.g:327:14: ' '
                        {
                            MATCHC(' ');
                            if  (HASEXCEPTION())
                            {
                                goto ruleWHITESPACEEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;
                    case 3:
                        // cif.g:327:20: EOL
                        {
                            /* 327:20: EOL */
                            mEOL(ctx );
                            if  (HASEXCEPTION())
                            {
                                goto ruleWHITESPACEEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;
                    case 4:
                        // cif.g:327:26: '\\u000C'
                        {
                            MATCHC(0x000C);
                            if  (HASEXCEPTION())
                            {
                                goto ruleWHITESPACEEx;
                            }
                            if (HASFAILED())
                            {
                                return ;
                            }

                        }
                        break;

                    default:

                        if ( cnt33 >= 1 )
                        {
                            goto loop33;
                        }
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return ;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleWHITESPACEEx;
                }
                cnt33++;
            }
            loop33: ;   /* Jump to here if this rule does not match */
        }

    }

        LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWHITESPACEEx; /* Prevent compiler warnings */
    ruleWHITESPACEEx: ;

}
// $ANTLR end WHITESPACE

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void
mTokens(pcifLexer ctx)
{
    {
        //  cif.g:1:8: ( T__33 | T__34 | T__35 | T__36 | T__37 | T__38 | T__39 | TAG | SEMI_COLON_TEXT_FIELD | LOOP_ | GLOBAL_ | STOP_ | DATA_BLOCK_HEADING | SAVE_FRAME_HEADING | SAVE | FLOAT | UNSIGNED_INTEGER | CHAR_STRING | COMMENTS | NON_BLANK_CHAR | WHITESPACE )

        ANTLR3_UINT32 alt34;

        alt34=21;

        alt34 = cdfa34.predict(ctx, RECOGNIZER, ISTREAM, &cdfa34);
        if  (HASEXCEPTION())
        {
            goto ruleTokensEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        switch (alt34)
        {
        case 1:
            // cif.g:1:10: T__33
            {
                /* 1:10: T__33 */
                mT__33(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 2:
            // cif.g:1:16: T__34
            {
                /* 1:16: T__34 */
                mT__34(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 3:
            // cif.g:1:22: T__35
            {
                /* 1:22: T__35 */
                mT__35(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 4:
            // cif.g:1:28: T__36
            {
                /* 1:28: T__36 */
                mT__36(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 5:
            // cif.g:1:34: T__37
            {
                /* 1:34: T__37 */
                mT__37(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 6:
            // cif.g:1:40: T__38
            {
                /* 1:40: T__38 */
                mT__38(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 7:
            // cif.g:1:46: T__39
            {
                /* 1:46: T__39 */
                mT__39(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 8:
            // cif.g:1:52: TAG
            {
                /* 1:52: TAG */
                mTAG(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 9:
            // cif.g:1:56: SEMI_COLON_TEXT_FIELD
            {
                /* 1:56: SEMI_COLON_TEXT_FIELD */
                mSEMI_COLON_TEXT_FIELD(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 10:
            // cif.g:1:78: LOOP_
            {
                /* 1:78: LOOP_ */
                mLOOP_(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 11:
            // cif.g:1:84: GLOBAL_
            {
                /* 1:84: GLOBAL_ */
                mGLOBAL_(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 12:
            // cif.g:1:92: STOP_
            {
                /* 1:92: STOP_ */
                mSTOP_(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 13:
            // cif.g:1:98: DATA_BLOCK_HEADING
            {
                /* 1:98: DATA_BLOCK_HEADING */
                mDATA_BLOCK_HEADING(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 14:
            // cif.g:1:117: SAVE_FRAME_HEADING
            {
                /* 1:117: SAVE_FRAME_HEADING */
                mSAVE_FRAME_HEADING(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 15:
            // cif.g:1:136: SAVE
            {
                /* 1:136: SAVE */
                mSAVE(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 16:
            // cif.g:1:141: FLOAT
            {
                /* 1:141: FLOAT */
                mFLOAT(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 17:
            // cif.g:1:147: UNSIGNED_INTEGER
            {
                /* 1:147: UNSIGNED_INTEGER */
                mUNSIGNED_INTEGER(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 18:
            // cif.g:1:164: CHAR_STRING
            {
                /* 1:164: CHAR_STRING */
                mCHAR_STRING(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 19:
            // cif.g:1:176: COMMENTS
            {
                /* 1:176: COMMENTS */
                mCOMMENTS(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 20:
            // cif.g:1:185: NON_BLANK_CHAR
            {
                /* 1:185: NON_BLANK_CHAR */
                mNON_BLANK_CHAR(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;
        case 21:
            // cif.g:1:200: WHITESPACE
            {
                /* 1:200: WHITESPACE */
                mWHITESPACE(ctx );
                if  (HASEXCEPTION())
                {
                    goto ruleTokensEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }
            break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

// $ANTLR start synpred1_cif
static void synpred1_cif_fragment(pcifLexer ctx )
{
    // cif.g:271:7: ( SINGLE_QUOTE NON_BLANK_CHAR_ )
    // cif.g:271:8: SINGLE_QUOTE NON_BLANK_CHAR_
    {
        /* 271:8: SINGLE_QUOTE NON_BLANK_CHAR_ */
        mSINGLE_QUOTE(ctx );
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_cifEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 271:8: SINGLE_QUOTE NON_BLANK_CHAR_ */
        mNON_BLANK_CHAR_(ctx );
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_cifEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred1_cifEx; /* Prevent compiler warnings */
rulesynpred1_cifEx: ;

}
// $ANTLR end synpred1_cif

// $ANTLR start synpred2_cif
static void synpred2_cif_fragment(pcifLexer ctx )
{
    // cif.g:277:7: ( DOUBLE_QUOTE NON_BLANK_CHAR_ )
    // cif.g:277:8: DOUBLE_QUOTE NON_BLANK_CHAR_
    {
        /* 277:8: DOUBLE_QUOTE NON_BLANK_CHAR_ */
        mDOUBLE_QUOTE(ctx );
        if  (HASEXCEPTION())
        {
            goto rulesynpred2_cifEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 277:8: DOUBLE_QUOTE NON_BLANK_CHAR_ */
        mNON_BLANK_CHAR_(ctx );
        if  (HASEXCEPTION())
        {
            goto rulesynpred2_cifEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred2_cifEx; /* Prevent compiler warnings */
rulesynpred2_cifEx: ;

}
// $ANTLR end synpred2_cif

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */

/* =========================================================================
 * Lexer syntactic predicates
 */
static ANTLR3_BOOLEAN synpred1_cif(pcifLexer ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start       = MARK();
    synpred1_cif_fragment(ctx);     // can never throw exception
    success     = !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG  = ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred2_cif(pcifLexer ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start       = MARK();
    synpred2_cif_fragment(ctx);     // can never throw exception
    success     = !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG  = ANTLR3_FALSE;
    return success;
}

/* =========================================================================
 * Lexer syntactic predicates end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */


/* End of code
 * =============================================================================
 */
